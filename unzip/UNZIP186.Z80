; UNZIP.Z80
;
;	Dissolves all MS-DOS ZIP files.
;
	.z80
Vers	equ	18
Revisn	equ	6	;;v1.8-6
;
; Version 1.8-6 -- December 2, 2020 -- Lars Nelson
;	Changed the output format to be more like UNARC.  Now
;	shows compressed and uncompressed file size, PKZIP 
;	version #, Compression Method, modification date 
;	and time and 32 bit CRC.
;
; Version 1.8-5 -- November 11, 2020 -- Lars Nelson
;	Added datestamping.  ZIP file Modification date is applied
;	if running on a ZSDOS, CP/M Plus or CP/M 2.2 systems with
;	datestamping support.
;
; Version 1.8-4 -- October 18, 2020 -- Russell Marks and Lars
;	Made slight optimisations to bit-readers, fixed long-filename 
;	buffer overrun, added removal of directory path from filename
;	and added various comments.	
;
;	Used self-modifying code with an unrolled end loop in rdbybits,
;	and added a "rd1bit" macro, for about a 12% speed improvement
;	on overall extraction time compared to version 1.5-3.

;	Improvement on overall extraction time of 38% total
;	compared to Version 1.8.
;	Added some basic comments to code/data based mostly on the
;	https://en.wikipedia.org/wiki/Zip_(file_format)
;	format description.
;
; Version 1.8-3 -- October 15, 2020 -- Russell Marks
;	More optimisations to improve the speed of the UnDeflate
;	method.
;
;	Calls to readbits when an eight or fewer bit value is
;	passed optimised to a new rdbybits routine (about a 20%
;	speed improvement).
;	Cosmetic change the "V" label to "urV" for assembly with
;	zmac under Unix.
;	Output a message when there is insufficient TPA available.
;	Use a table-based CRC algorithm.  This increases
;	code size by about 1Kbyte and boosts the speed by more
;	than 30% compared to version 1.5-2.
;
; Version 1.8-2 -- September 3, 2020 -- Martin and Lars
;	Major & minor Improvments plus bug fixes.
;
;	Fixed extraction of zero-length files.
;	Skip to the next file header if the compression method is unknown.
;	Fixed readbits when a full word (16 bits) is read (in preparation
;	for implementing the unDeflate algorithm).
;	Fixed mis-ordering of variables.  Code makes the assumption
;	that "bitbuf" is the byte before "bleft".
;	Added the UnDeflate algorithm (based on the work by
;	Keir Fraser's HiTech-C code at
;	https://github.com/keirf/Amiga-Stuff/blob/master/inflate/degzip_portable.c
;	Had to reduce I/O Buffers to 2K each because of available memory

; Version 1.8-1 -- June 17, 2020 -- Martin
;	Fixed flaws in both the un-implode and un-shrink routines
;	that were found to be causing CRC errors or program crashes.
;
;	For un-implode, the algorithm is essentially a translation
;	of the PKZ101 MS-DOS algorithm in C that has been hand optimized
;	into Z80 assembly language.  However, the readtree() function
;	was incorrectly returning a byte value in the A register, when
;	the shift routine at label ui5 was expecting a 16-bit value in HL.
;
;	For unshrink, there is a race condition with handling the "KwKwK"
;	case that was omitted from the routine.
;
;	Both updates are flagged with ;;v1.8-1 comments, and the
;	version sign-on message now includes the revision.

; Version 1.8 -- April 16, 1992 -- Howard Goldstein
;	Fixed "unreducing" code which I inadvertently broke in version
;	1.6.

; Version 1.7 -- April 8, 1992 -- Howard Goldstein
;	Fixed problem where long ZIP comments were clobberiog data and
;	causing strange errors.  Fixed typo in help screen.  Can now be
;	assembled with M80 again.

; Version 1.6 -- April 3, 1992 -- Howard Goldstein
;	Improved performance by incorporating an 8k output buffer and a
;	dynamically allocated input buffer of up to 8k.  The program no
;	longer expands and checks the CRC of a Zipfile member that is
;	being skipped.  The keyboard is checed for control-c less
;	frequently which also speeds things up a bit.  All console output
;	is now done via direct console IO making control-c checking more
;	reliable.  I also made the program reentrant and changed the order
;	of events so that the destination directory is checked for a
;	file's existence AFTER it has been determined that the file is to
;	be extracted, not before as was the case previously.

; Version 1.5 -- june 1, 1991 -- Howard Goldstein
;	Fixed bug at WILDLP which was causing an output spec of "dir:"
;	not to work correctly.  Corrected problems that were causing
;	writes to disk when a non-matching member file was being skipped.
;	Changed "disk full" logic to close and erase partial output file
;	and abort the program immediately.  Made several minor changes to
;	allow assembly with ZMAC or M80.

; Version 1.4 -- May 16, 1991 -- Bruce Morgen
;	Fixed bug at "setusr" and added output filename wildcard
;	support.  If the selected output filespec is NOT wild,
;	(and d: or dir: alone IS wild) UNZIP will exit after the
;	first extraction.  Boy, do I have a headache....

; Version 1.3 -- May 12, 1991 -- Gene Pizzetta
;	Some quick and dirty mods to make this utility more useful.
;	The original has to be the most God-awful source code I've
;	ever come across.  It is totally uncommented, and I have
;	no idea what kind of strange assembler it was written for.
;	This code now assembles with SLR's Z80ASM and it's a little
;	more orderly.
;
;	New syntax:
;		UNZIP {dir:}zipfile {dir:}{afn}
;	Under ZCPR3 "dir" can be a DU or DIR spec; otherwise, just
;	a drive.  If no destination is given, member files are checked
;	and listed.  If a destination is given, member files are
;	extracted if they match "afn" if given, otherwise the entire
;	ZIPfile is extracted.
;
;	You can now abort this thing with ^C (and the partial output
;	file, if any, will be closed and erased).  Usage screen now
;	responds to "//".  This program still needs a lot of work.
;	It's probably not bullet-proof and testing has been very
;	limited, but it seems to work.
;
; Version 1.2 -- July 3, 1990 -- David P. Goodenough
;
; Production:
;   To use to Microsoft compatible libraries SYSLIB, ZSLIB and Z3LIB,
; move these libraries to the default directory and set the conditional
; assembly equate 'SLRlibs' below false.
;   Assemble with ZMAC, Z80ASM or M80:
;	ZMAC UNZIP186, Z80ASM UNZIP186/M or M80 =UNZIP186
;   Link with ZML, SLRNK or LINK.  For ZML simply type
;	zml unzip186
; Linking with SLRNK or LINK is more complicated.  For SLRNK, first
; make a trial link:
;	SRLNK /A:2000,UNZIP186/P:100,UNZIP186/N/E
; take the number in parens in the output, add 100h to it and replace
; the 2000 above with the result and make a final link.
; For LINK do the following
;	LINK UNZIP186
; Note the CODE SIZE displayed in screen output, add 100h to it and
; denote result as N.  LINK includes unitialized data in the COM file
; producing a 48k output.  To reduce COM file size, use the CP/M Plus
; version of SID as follows:
;	SID UNZIP186.COM
;	WUNZIP186,100,N
;	G0
; Have been unable to get L80 to link.
;   To use SLR compatible libraries SYSLIBS, ZSLIBS and Z3LIBS, copy
; these libraries to the default directory and set the conditional
; assembly equate 'SLRlibs' below true. Then assemble with Z80ASM
;	Z80ASM UNZIP186/R
; In this case, SLRNK is the only linking option.  Use the two step
; linking process described above to produce a COM file.
;
FALSE	equ	0
TRUE	equ	not FALSE
;
; conditional assembly equates
;
debug	equ	TRUE		; set true to reduce I/O buffers
				; to 256 bytes so that there is enough
				; free TPA to run a debugger
SLRlibs	equ	false		; set true to link with SLR compatible 
				; libraries and false to link with
				; Microsoft compatible libraries
;
; User equates
;
	 if	DEBUG
obfsiz	equ	1		; 1-page (256) fixed output buffer
ibfmax	equ	1		; 1-page (256) max. for input buffer
	 else
;obfsiz	equ	32		; 32-page (8k) fixed output buffer
;ibfmax	equ	32		; 32-page (8k) max. for input buffer
obfsiz	equ	8		; 8-page (2k) fixed output buffer
ibfmax	equ	8		; 8-page (2k) max. for input buffer
	 endif
;
; System addresses
;
wboot	equ	0
bdos	equ	5
dfcb	equ	5Ch
altfcb	equ	6Ch
;
; BDOS service functions
;
dircon	equ	6
fsearch	equ	17
getdrv	equ	25
setusr	equ	32
;
; Other
;
STRSIZ	equ	256		; must be 256 exactly, see plfh for why
DLE	equ	144
max_bits equ	13
init_bits equ	9
hsize	equ	8192
first_ent equ	257
clear	equ	256
maxcmax	equ	1 shl max_bits
maxSF	equ	256
_code	equ	0
_value	equ	2
_bitlength equ	3
_entries equ	0
_maxlength equ	2
_entry	equ	4
_sf_tree_ equ	4 + 4 * maxSF
maxcl	equ	16
nrcl	equ	19
nrlit	equ	288
nrdist	equ	32
;
; ASCII
;
CtrlC	equ	03h
CR	equ	0Dh
LF	equ	0Ah
CtrlZ	equ	1Ah
;
	 if SLRlibs
	.request zslibs
	ext	fxropen,fxwopen,fxrclose,fxwclose,fxget,fxput,sstpcp
	ext	z3init,zcheck,bdostyp,gua,sua,pdats2,ptims1,plwdc,phl2dc
;
	.request z3libs
	ext	z3log
;
	.request syslibs
	ext	f$close,f$delete,initfcb,PFN1,PHL4HC
;
	.request dslibs
	ext	timini,pstamp,DOSTYP,TIMTYP
;
	 else
;
	.request zslib
	ext	fxrope, fxwope, fxrclo,  fxwclo,  fxget,fxput,sstpcp
	ext	z3init,zcheck,bdostyp,gua,sua,pdats2,ptims1,plwdc,phl2dc
;
	.request z3lib
	ext	z3log
;
	.request syslib
	ext	f$clos, f$dele,  initfc, PFN1, PHL4HC
;
	.request dslib
	ext	timini,pstamp,DOSTYP,TIMTYP
	 endif
;
	public	$memry
;
	jp	start
;
	db	'Z3ENV',1
Z3EAdr:	dw	0
;
start:
;	ld	(oldstk),sp	; save old stack here for future use
	ld	sp,locstk	; set the local stack pointer
        LD      HL,Z3EADR       ; trial environment address in HL
;        CALL    ZCHECK          ; makes HL = 0 if no environment
;        CALL    Z3INIT          ; initialize ENVPTR
	call	timini		; check for datestamping support
	; Global variables returned:
	; DOSTYP ='S'=>ZSDOS, 'D'=>Datestamper & '3'=>CP/M Plus.
	;    0=>no datestamping
	; DOSVER has version number, 22=>CP/M 2.2 and
	; compatiblle. 
	call	ilprt
	db	'UNZIP Version '
	db	Vers/10+'0','.',Vers mod 10+'0'
	db	'-',Revisn mod 10+'0'	;;v1.8-1 identify revision
	db	' - DPG',CR,LF,0
	ld	a,(dfcb+1)	; filename?
	cp	' '
	jp	z,usage
	cp	'/'
	jp	z,usage
;
wasfil:	ld	hl,0
	ld	(zipeof),hl	; init "zipeof" and "counting"
	ld	(opnflg),hl	; init "opnflg" and "conckct"
;
; Determine buffer addresses.  Output buffer size is defined by Obfsiz
; and input buffer size is either remaining memory or Ibfmax, whichever is
; less.
;
	ld	hl,($memry)	; top of dseg
	ld	(opbuf),hl	; store as output buffer address
;;	 if	debug
;;	ld	de,80h		; size of output buffer
;;	ld	a,1		; # of records
;;	 else
	ld	de,obfsiz shl 8	; output buffer size (pages)
	ld	a,d
	add	a,a		; convert to records
;;	 endif
	ld	(ocb),a		; and store in output control block
	add	hl,de		; determine address of input buffer
	ld	(ipbuf),hl
;;	 if	debug
;;	add	hl,de
;;	 endif
	ex	de,hl		; get buffer address in de
;;	 if	not debug
;;	inc	d		; assume 1 page for input buffer
;;	 endif
	ld	hl,(bdos+1)	; top of memory
	xor	a		; clear accumulator and carry
	sbc	hl,de		; hl = memory available less 1 page
	jp	c,nomem
;;	 if	debug
;;	ld	a,1
;;	 else
	inc	h		; now = total memory available
	rl	l		; shift possible extra record to carry
	adc	a,h
	add	a,h		; a = max input buffer records
	ld	b,ibfmax * 2
	cp	b		; compare computed to optimum value
	jr	c,sticb		; computed value smaller, use it
	ld	a,b		; else use optimum
;;	 endif
sticb:	ld	(icb),a		; store in input control block
;
	ld	a,(altfcb)
	ld	(mode),a	; set the mode (non-zero = extract)
	or	a
	jr	z,chkn
	call	ilprt
	db	'Extracting ',CR,LF,0
	jr	gu
chkn:	call	ilprt
	db	'Checking ',CR,LF,0
gu:	call	getusr		; set default user if not ZCPR3
	ld	hl,mtchfcb
	ld	bc,11
	ld	de,altfcb + 1
	ld	a,(de)
	cp	20h
	jr	z,wildfill
; copy destination filename to mtchfcb
	ex	de,hl
	ldir
	ld	a,(altfcb)	; get destination drive
	or	a		; is it default?
	jr	nz,filldn	; jmp if not
	ld	c,getdrv	; get default drive
	call	bdos
	inc	a
	ld	(altfcb),a	; store it for Z3LOG
	jr	filldn
wildfill:			; fill mtchfcb file & ext with '?'
	ld	b,c
wildlp:	ld	(hl),'?'
	inc	hl
	djnz	wildlp
filldn:	ld	a,(dfcb+9)	; check for filetype
	cp	20h
	jr	nz,wasext
	ld	hl,+('I' shl 8) + 'Z'	; set default type to ZIP
	ld	(dfcb+9),hl
	ld	a,'P'
	ld	(dfcb+11),a
wasext:	call	ilprt
	db	'ZIP archive  = ',0
	ld	de,dfcb+1
	call	PFN1
	call	ilprt
	db	CR,LF,0
	ld	de,dfcb
	call	z3log		; log input drive/user
	ex	de,hl
	inc	hl
	ld	bc,11
	ld	de,infcb+1
	ldir			; move filename to working fcb
	ld	de,icb
	 if SLRlibs
	call	fxropen		; try to open zipfile
	 else
	call	fxrope		; try to open zipfile
	 endif
	jp	z,badopen	; ok
	call	ilprt		
;	db	cr,lf
	db	'Name         Length  Stored   Method   Ver  File Date'
	db	' & Time    CRC    STATUS',CR,LF
	db	'============ ======= =======  ======== ===  ========='
	db	'  =====  ======== =======',CR,LF,0
	jr	openok
badopen:
	call	ilprt		; complain and go to exit
	db	'Couldn''t find ZIP file',CR,LF,0
	jr	exit
;
nomem:	call	ilprt		; complain and fall through to exit
	db	'Not enough memory!',cr,lf,0
;
; All exits point here for possible future enhancements, such
; as elimination of warm boot.
;
exit:	call	ilprt
	db	'         ',CR,0
	rst	0		; warmboot
;
sigerr:	call	ilprt
	db	'Bad signature in ZIP file',CR,LF,0
	jr	exit
;
; Judging from https://en.wikipedia.org/wiki/Zip_(file_format)
; this appears to read the file in a technically incorrect way,
; by relying on the local file header only (as a zip-fixing
; program might), and simply skipping past the central directory
; entirely. This leaves us potentially extracting deleted files,
; for example. It's probably not a real problem in most
; cases, but it seemed worth noting.
;
; should be pointing at beginning of either a Local file
; header or a Central Directory Structure
; 1st and 2nd bytes should be 'KP' (Phil Katz's initials little endian)
; 3rd and 4th bytes should be either 0403h or 0201h
; where 403h => local header and 201 => Central Directory
; Structure which is at the end of the input file. 
; 605h=>end central dir.  Note only interested in local 
; header which preceeds each compressed file.
; Check for valid header signature.
openok:
	ld	hl,0
	ld	(zipeof),hl		; clear zipeof and counting
	call	getword
	ld	de,-(('K' shl 8) + 'P')	; Phil Katz's initials!
	add	hl,de
	ld	a,h
	or	l		; hl=0 =>valid signature?
	jr	nz,sigerr
	call	getword
	dec	l		; is l=1
	jr	nz,nocfhs	; jmp if not cfh
	dec	h		; possible cfh, is h=2?
	dec	h
	jr	nz,sigerr	; jmp if not chf
	call	pcfh
	jr	openok
;
nocfhs:	dec	l		;chk for lfh, is l=2?
	dec	l
	jr	nz,nolfhs	; jmp if not lfh
	ld	a,h		; possiblr lfh, is h=4
	sub	4
	jr	nz,sigerr	; jmp if not
	call	plfh		; process local file header
	jr	openok
;
nolfhs:	dec	l		; check for 05,06 (end of central dir.)
	dec	l
	jr	nz,sigerr
	ld	a,h
	sub	6
	jr	nz,sigerr
	call	pecd
; close input file and exit program
clsxit:	ld	de,icb
	 if SLRlibs
	call	fxrclose
	 else
	call	fxrclo
	 endif
	jr	exit
;
; (The belated-CRC type (07,08) is apparently not supported.)
;
; pcfh/pecd are not truly required, they only serve to skip past
; the central directory and end-of-central-directory blocks. But
; they do arguably serve as a small additional check of file
; integrity. It would be faster to simply exit when we spot the
; central directory signature (since the CD/EOCD are by definition
; the last two things) - for large files this might be noticeable.
;
; pcfh - skip past central directory
;
pcfh:	ld	b,12		; skip ahead to filename length entry
pcfhl1:	push	bc
	call	getword
	pop	bc
	djnz	pcfhl1
	call	getword
	push	hl
	call	getword
	push	hl
	call	getword
	pop	de
	pop	bc
	push	hl		; file comment length
	push	de		; extra field length
	push	bc		; filename length
	ld	b,6		; skip ahead to filename
pcfhl2:	push	bc
	call	getword
	pop	bc
	djnz	pcfhl2
	pop	hl
	call	skpstring	; skip past filename
	pop	hl
	call	skpstring	; skip past extra field
	pop	hl
	call	skpstring	; skip past file comment
	ret
;
; pecd - skip past end-of-central-directory
;
pecd:	ld	b,8		; skip ahead to comment length
pecdl:	push	bc
	call	getword
	pop	bc
	djnz	pecdl
	call	getword		; comment length
	call	skpstring	; skip past comment
	ret
;
; plfh - read local file header, then extract/check file
;
; NB: As mentioned above, this is technically not the correct
; approach to take (but it's almost certainly faster this way
; and will do the right thing for most zips).
;
plfh:	ld	de,lfh
	ld	hl,endlfh-lfh
	call	getstring
;
; Read filename from LFH into "junk". Note: ZIP file spec
; allows 65535 char filenames!  There is a very small chance that
; a complete filename including directory path could exceed 256
; bytes. The directory path is meaningless to CP/M and needs to
; striped off.  After this there still remains the problem that
; the filename itself may be greater than 8 chars.  Here only 
; the first 8 chars are used and the rest discarded.  There may
; be better solutions.  The 3 chars after a '.' are taken as
; the extension.
;
	ld	de,junk		; put filename here
	ld	hl,(fnl)	; filename length
; read a byte at a time, reseting DE everytime a path seperator
; is encountered until all bytes in the filename have been read.
; '/', '\' and ':' are considered path seperators.  Assumes 
; filename without path does not exceed 255 chars.
rfnlp:
	ld	a,h
	or	l
	jr	z,rdfndon
	push	de
	push	hl
	call	getbyte
	pop	hl
	pop	de
; check for path seperators
	cp	'/'
	jr	z,gotsep
	cp	'\'
	jr	z,gotsep
	cp	':'
	jr	nz,nosep
gotsep:	ld	de,junk		;reset save pointer
	jr	nosav		;don't save seperator
nosep:	cp	'a'
	jr	c,nolc
	and	5fh		;capitalize
nolc:	ld	(de),a		;save char in junk
	inc	de
nosav:	dec	hl
	jr	rfnlp
rdfndon:
	ld	(de),a		; save null terminator
	ld	hl,(efl)
	call	skpstring	; skip extra field

; Path removed, now copy filename to FCB.
;
	ld	de,opfcb
	 if SLRlibs
	call	initfcb
	 else
	call	initfc		;clear fcb except filename
	 endif
	ex	de,hl
	inc	hl		;point to filename
	ld	de,junk
	ld	b,8
	call	scanfn
	ld	a,(de)
	cp	'.'
	jr	nz,nodot
	inc	de
nodot:	ld	b,3
	call	scanfn
; Process the file, either extract files matching template if 
; destination drive given or check CRC for every file file that
; matches destination template.  Do not extract if it already 
; exists on host.  This mimics the way UNARC works.
; Initialize
	ld	hl,init
	ld	de,vars
	ld	bc,endinit-init
	ldir
	ld	a,(mode)
resmod:	ld	(curmode),a
; Check if filename matches the destination template
	ld	b,11
	ld	hl,opfn
	ld	de,mtchfcb
mtchlp:
;   See if the name matches the destination
	ld	a,(de)
	ld	c,(hl)
	inc	hl
	inc	de
	cp	'?'
	jr	z,mtch1
	res	7,c
	cp	c
	jr	z,mtch1
	call	ilprt		; no match so skip file
	db	' Skipping',CR,0
	jp	skipit
mtch1:	djnz	mtchlp
; Filename matches
	ld	a,(curmode)
	or	a
	jp	z,pjunk
; check if file already exits
mtchex:	call	setout		; log output drive/user
	ld	de,opfcb	; see if output file already exists
	ld	c,fsearch	; search directory
	call	bdos
	inc	a
	jr	z,creok		; doesn't exist so go extract
; file already exists, so tell user then skip it
	ld	de,OPfcb+1
	call	PFN1			
; print uncompressed and compressed file size
	call	opsiz
; the following converts compression method code to a name and outputs it
; for now it is bypassed and x's output instead
;	ld	a,(cm)
;	add	a
;	add	a
;	add	a
;	ld	e,a
;	ld	d,0
;	ld	hl,namtab
;	add	hl,de
;	call	vpstr
	call	ilprt
	db	'xxxxxxxx',0
; print version, date and time
	call	opver
	call	ilprt
	db	'EXISTS',CR,LF,0	;lwn
	jp	skipit
; create output file if extracting
creok:	ld	de,ocb		; create output file
	 if SLRlibs
	call	fxwopen
	 else
	call	fxwope
	 endif
	jr	nz,opnok1
	call	ilprt
	db	'Error creating ',0
	ld	hl,junk
	call	pstr
	jp	exit			; quit if create file fails
;
opnok1:	ld	(opnflg),a
pjunk:
	ld	de,OPfcb+1
	call	PFN1			
; print uncompressed and compressed file size
	call	opsiz
doext:	ld	hl,counting
	inc	(hl)
	call	ilprt
	db	' ',0
	ld	a,(cm)		; get compression method
	or	a
	jr	nz,case1
; file is stored
; - first check for zero length file
	ld	hl,(cs)
	ld	de,(cs+2)
	ld	a,l
	or	h
	or	e
	or	d
	jr	nz,case0x
	ld	hl,zipeof	;zero length so set eof flag
	inc	(hl)
case0x:
	call	ilprt
	db	' Stored ',0
; print version, date and time
	call	opver
; copy stored file to output
case0w:	ld	a,(zipeof)	; check eof flag
	and	1		; oef if odd
	jp	nz,closeo
	call	getbyte
	call	outbyte
	jr	case0w
; is this file shrunk?
case1:	dec	a
	jr	nz,case2p
	call	unshrink
	jr	closeo
; is this file reduced?
case2p:	dec	a
	cp	4
	jr	nc,tryimp
	call	unreduce
	jr	closeo
; is this file imploded?
tryimp:	jr	nz,trydfl
	call	unimplode
	jr	closeo
; is file deflated
trydfl:	cp	6
	jr	nz,badzip
	call	undeflate
	jr	closeo
; Bad or unknown compression method
badzip:	call	ilprt
	db	'Unknown compression method -- Skipping',CR,LF,0
skipit:	xor	a
	ld	(curmode),a	; set to no extract
	inc	a
	ld	(counting),a	; make sure getbyte counts bytes
badskp:	ld	a,(zipeof)	; get eof flag
	and	1		; eof?
	jr	nz,skpdun
	call	getbyte
	jr	badskp
skpdun:	ld	hl,zipeof	; point to eof flag
	dec	(hl)		; clear it
	inc	hl		; point to counting
	dec	(hl)		; decrement it
	ret
;
closeo:	call	skpdun
	ld	a,(curmode)	; check mode for this file
	or	a
	jr	z,nocls
close1:	ld	de,ocb
	 if SLRlibs
	call	fxwclose
	 else
	call	fxwclo
	 endif
	jp	z,wrterr
	xor	a
	ld	(opnflg),a
; if system supports datestamping - set all datestamps of extracted
; files with stamp from local file header.
; Test if datestamping available
	ld	a,(DOSTYP)
	or	a
	jr	z,nods		; jmp if no datestamping
; copy date & time to opbuf as create stamp
	ld	hl,dsbuf
	ld	de,(opbuf)
	ld	bc,5
	ldir
; Fill in Datestamp for access and modify
	ld	bc,10		; copy to access & modify stamps
	ld	hl,(opbuf)
	ldir
; set the file's date stamp
	ld	hl,(opbuf)	; date stamp pointer
	ld	de,opfcb	; file fcb
	ld	a,(DOSTYP)
	cp	33h		; test for CP/M Plus
	jr	z,dods3
	cp	'S'		; test for ZSDOS or ZDDOS
	jr	z,dods
	cp	'D'		; test for DateStamper
	jr	nz,nods
dods:	call	pstamp		; set file date/time stamp
	or	a
	jr	z,daterr
	jr	nods
dods3:	ld	bc,followers	; borrow 1k of buffer space
	call	sstpcp
	or	a
	jr	nz,daterr
nods:
nocls:	ld	hl,crc32
	ld	de,crc
	scf
	ld	bc,4 shl 8
crcclp:	ld	a,(de)
	adc	a,(hl)
	push	af
	or	c
	ld	c,a
	pop	af
	inc	hl
	inc	de
	djnz	crcclp
	ld	a,c
	or	a
	jr	z,crcok
	call	ilprt
	db	'CRC ERR',CR,LF,0
	jr	wildck
;
crcok:	call	ilprt
	db	'CRC OK',CR,LF,0
; 
wildck:
	ld	a,(curmode)
	or	a
	ret	z
	ld	hl,mtchfcb
	ld	bc,11
	ld	a,'?'
	cpir
	jp	nz,clsxit
	ret
;
daterr:
	call	ilprt
	db	'Date Stamp Error',CR,LF,0
	jr	wildck
;
getchla:
	call	getcode
	ld	(code),hl
	ld	a,(zipeof)	; get eof flag
	and	1		; eof?
	ret
;
savstk:	ld	hl,(stackp)
	dec	hl
	ld	(stackp),hl
	ld	(hl),a
	ret
;
getcode:
	ld	a,(codesize)
readbits:
	ld	b,a
	ld	c,80h		; bits rotate into C and A
	xor	a		; (rra is 4 cycles vs 8 for others)
	ld	hl,(bitbuf)	; keep bitbuf in L, bleft in H
getbit:	dec	h
	jp	p,getbt2	; skip if new byte not needed yet
	push	af
	push	bc
	call	getbyte
	ld	l,a		; new bitbuf
	ld	h,7		; 8 bits left, pre-dec'd
	pop	bc
	pop	af
getbt2:	rr	l
	rr	c
	rra
	jr	c,bitret
	djnz	getbit
finbit: srl	c
	rra
	jp	nc,finbit	; jp likely faster in this case
bitret:	ld	(bitbuf),hl	; update bitbuf/bleft
	ld	h,c		; return bits in HL and A
	ld	l,a
	ret
;
; rdbybits - faster version of readbits for <=8 bits.
; Due to the implementation this must not ever be called with A>8.
; (No caller seems to require saving BC, so I removed that for both
; this and readbits.)
;
rdbybits:
	ld	(rdbyop+1),a	; modify jr instruction at rdbyop
	ld	b,a
	xor	a		; bits rotate into A (rra faster)
	ld	hl,(bitbuf)	; keep bitbuf in L, bleft in H
rdbylp:	dec	h
	jp	p,rdby1		; skip if new byte not needed yet
	ld	c,a
	push	bc
	call	getbyte
	ld	l,a		; new bitbuf
	ld	h,7		; 8 bits left, pre-dec'd
	pop	bc
	ld	a,c
rdby1:	rr	l
	rra
	djnz	rdbylp
	ld	(bitbuf),hl	; update bitbuf/bleft
	or	a
rdbyop:	jr	rdbyr8
rdbyr8:	rra			; 8x rra, not all are used in practice but
	rra			; this arrangement simplifies code above
	rra
	rra
	rra
	rra
	rra
	rra
	ld	h,b		; B still zero after the final djnz
	ld	l,a		; return bits in HL and A
	ret
;
; rd1bit - faster version which reads a single bit only.
; The jp instruction here needs the uses of a local symbol
; The "local" statement must be right after "macro"
;
rd1bit	macro
	local	??0001
	ld	hl,(bitbuf)	;; keep bitbuf in L, bleft in H
	dec	h
	jp	p,??0001	;; jump to "xor a", past jp op plus 6 bytes:
	call	getbyte		;; (3 bytes)
	ld	l,a		;; (1 byte)  new bitbuf
	ld	h,7		;; (2 bytes) 8 bits left, pre-dec'd
??0001:	xor	a		;; jp op above jumps here
	rr	l
	ld	(bitbuf),hl	;; update bitbuf/bleft
	ld	h,a		;; A still zero
	rla			;; return bit in HL and A
	ld	l,a
	endm
;
; copy filename string of max length (BE) starting at (DE) to memory
; starting at (HL) stop copying if a null or period is encountered
; and pad remainder with spaces.
scanfn:	ld	a,(de)
	cp	'.'
	jr	z,nocopy
	or	a
	jr	z,nocopy
	inc	de
	dec	b
	jp	m,scanfn
	and	7fh		; remove high bit
	ld	(hl),a
	inc	hl
	jr	scanfn
;
nocopy:	dec	b
	ret	m
	ld	(hl),' '
	inc	hl
	jr	nocopy
;
; In-Line print null terminated string
ilprt:	pop	hl
	call	pstr
	jp	(hl)
;
; print null terminated string pointed to by HL
pstr:	ld	a,(hl)
	inc	hl
	or	a
	ret	z
	push	hl
	ld	e,a
	ld	c,dircon
	call	bdos
	pop	hl
;	inc	hl
	jr	pstr
;
; getstring - Read a string of bytes from input file
;   Enter:	DE=location to start storing string
;		HL=# of bytes get
;   Exit:	DE pointing just past the last byte stored
;
getstring:
	ld	a,h
	or	l
	ld	(de),a
	ret	z
	push	de
	push	hl
	call	getbyte
	pop	hl
	pop	de
	ld	(de),a
	inc	de
	dec	hl
	jr	getstring
;
; skpstring - read but do not save a string of bytes from 
;		the input file, ie skip over them
;   Enter:	HL=# of bytes to skip over
skpstring:
	ld	a,h
	or	l
	ret	z
	push	hl
	call	getbyte
	pop	hl
	dec	hl
	jr	skpstring
;
getword:
	call	getbyte
	push	af
	call	getbyte
	pop	hl
	ld	l,h
	ld	h,a
	ret
;
; getbyte - get a byte from input file in A.  If 'counting' NZ then
;	decrement compressed file size and set 'zipeof' if size
;	goes to zero, ie count the bytes read.  If 'counting'
;	is Z, read until 'zipeof', set it and then return Ctrl-Z.
;
getbyte:
	ld	a,(counting)
	or	a
	jr	nz,dodci
	ld	a,(zipeof)	; get eof flag
	and	1		; test if eof
	ld	a,CtrlZ
	ret	nz		; at eof so return CtrlZ
	jr	skpdci
dodci:
	ld	hl,(cs)		; get compressed file size
	ld	de,(cs + 2)
	ld	a,d
	or	e		; test if file length zero
	or	h
	or	l
	jr	nz,noteof	; jmp if length not 0
	ld	hl,zipeof
	inc	(hl)		; set eof
	ld	a,CtrlZ		; and return a CtrlZ
	ret
;
noteof:	ld	a,h		; decrement 32 bit compressed file size
	or	l
	dec	hl
	ld	(cs),hl		; low order word
	jr	nz,skpdci	; do we need to borrow
	dec	de
	ld	(cs + 2),de	; save high order word
skpdci:	call	ckcon		; check console for abort
	ld	de,icb
	call	fxget		; get a byte from zip file
getadr	equ	$-2		; addr of input routine
	ret	nz		; return if read successful
	ld	a,CtrlZ		; read error - return Ctrl-Z
	ret
;
; read input from 'static_pre'
rdstat:	ld	hl,(inbps)	; get pointer in table
	ld	a,(hl)		; get byte from table
	inc	hl		; point to next byte
	ld	(inbps),hl	; save it
	ret
;
outb:	ld	hl,(outpos)
	push	hl
	push	af
	ld	a,(omask)
	and	h
	ld	h,a
	pop	af
	ld	de,outbuf
	add	hl,de
	ld	(hl),a
	pop	hl
	inc	hl
	ld	(outpos),hl
	push	af
	ld	a,h
	or	l
	jr	nz,nopos
	ld	hl,(outpos + 2)
	inc	hl
	ld	(outpos + 2),hl
nopos:	pop	af
;
; outbyte - send byte in A to output file.  Count down uncompressed
;		file size and set 'zipeof' if result zero.
;
outbyte:
	push	af
	call	updcrc
; decrement uncompressed file size and set zipeof if result zero
	ld	hl,(ucs)
	ld	de,(ucs + 2)
	ld	a,h
	or	l
	dec	hl
	ld	(ucs),hl
	jr	nz,tsthl0
	dec	de
	ld	(ucs + 2),de
tsthl0:	ld	a,h		; test if zero
	or	l
	or	d
	or	e
	jr	nz,noeof
	ld	hl,zipeof	; set eof flag
	inc	(hl)
noeof:
; Send byte to output file only if extracting
	ld	a,(curmode)
	or	a
	jr	nz,noeof1
	pop	af
	ret
;
noeof1:	pop	af
	ld	de,ocb
	call	fxput
	ret	nz
wrterr:	call	ilprt
	db	'Write Error (Disk full)',CR,LF,0
	jp	ckcon0
;
; Update 32 bit CRC with byte in A
;
; based on this from crc32() in degzip_portable.c:
;    for (i = 0; i < len; i++)
;        crc = crc32_tab[(uint8_t)(crc ^ *b++)] ^ (crc >> 8);
;
updcrc:	ld	bc,(crc32)
	xor	c		; A=low byte of crc xor output byte
	ld	h,0
	ld	l,a
	add	hl,hl		; *2
	add	hl,hl		; *4
	ld	de,crc32tab
	add	hl,de
	ld	de,(crc32 + 2)
	; now DEBC is "crc", and HL points to low byte of
	; relevant crc32tab entry. Do the xor with "crc"/256,
	; starting from the low bytes.
	ld	a,(hl)
	xor	b
	ld	c,a
	inc	hl
	ld	a,(hl)
	xor	e
	ld	b,a
	inc	hl
	ld	a,(hl)
	xor	d
	ld	e,a
	inc	hl
	ld	d,(hl)		; high byte is a simple copy
	ld	(crc32 + 2),de
	ld	(crc32),bc
	ret
;
unshrink:
; print method
	call	ilprt
	db	' Shrunk ',0
; print version, date and time
	call	opver
	ld	a,1fh
	ld	(omask),a
	ld	a,init_bits
	ld	(codesize),a
	ld	hl,+(1 shl init_bits) - 1;
	ld	(maxcode),hl
	ld	hl,first_ent
	ld	(free_ent),hl
	ld	hl,prefix_of
	ld	de,prefix_of + 1
	ld	bc,512
	ld	(hl),c
	ldir
	ld	bc,16386 - 512
	ld	(hl),-1
	ldir
	ld	hl,suffix_of
sol:	ld	(hl),c
	inc	hl
	inc	c
	jr	nz,sol
	call	getchla
	ld	(oldcode),hl
	ret	nz
	ld	a,l
	ld	(finchar),a
	call	outbyte
unshlp:	ld	hl,stack
	ld	(stackp),hl
	ld	a,(zipeof)	; test if eof reached
	and	1
	ret	nz		; return if not
clrlp:	call	z,getchla
	ret	nz
	ld	a,h
	dec	a
	or	l
	jr	nz,noclr
	call	getchla
	ld	a,h
	or	a
	jr	nz,clrlp
	dec	l
	jr	z,bumpcs
	dec	l
	call	z,partial_clear
	jr	clrlp
;
bumpcs:	ld	hl,codesize
	inc	(hl)
	ld	a,(hl)
	cp	max_bits
	ld	hl,maxcmax
	jr	z,atmax
	ld	hl,1
maxclp:	add	hl,hl
	dec	a
	jr	nz,maxclp
	dec	hl
atmax:	ld	(maxcode),hl
	jr	clrlp
;
noclr:	ld	(incode),hl	;;v1.8-1 start unshrink fix
	add	hl,hl
	ld	de,prefix_of
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	ld	hl,(code)
	jr	nz,noKwKw
	ld	a,(finchar)
	call	savstk
	ld	hl,(oldcode)
noKwKw:	ex	de,hl
;
staklp:	ld	hl,100h
	or	a
	sbc	hl,de
	jr	nc,unstak
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	nz,noKw2
	ld	a,(finchar)
	call	savstk
	ld	de,(oldcode)
	jr	staklp
;
noKw2:	ld	hl,suffix_of
	add	hl,de
	ld	a,(hl)
	call	savstk
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	jr	staklp
;
unstak:	ld	hl,suffix_of
	add	hl,de
	ld	a,(hl)
	call	savstk
	ld	(finchar),a	;;v1.8-1 end of unshrink fix
	ld	de,(stackp)
unslp:	ld	hl,stack
	or	a
	sbc	hl,de
	jr	z,newent
	ld	a,(de)
	inc	de
	push	de
	call	outbyte
	pop	de
	jr	unslp
;
newent:	ld	hl,(free_ent)
	ld	(code),hl
	ex	de,hl
	ld	hl,1fffh
	or	a
	sbc	hl,de
	jr	c,full
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	bc,(oldcode)
	ld	(hl),c
	inc	hl
	ld	(hl),b
	ld	hl,suffix_of
	add	hl,de
	ld	a,(finchar)
	ld	(hl),a
getfre:	inc	de
	ld	hl,1fffh
	or	a
	sbc	hl,de
	jr	c,full1
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	nz,getfre
full1:	ld	(free_ent),de
full:	ld	hl,(incode)
	ld	(oldcode),hl
	jp	unshlp
;
partial_clear:
	ld	de,first_ent
l8:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br8
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	set	7,(hl)
	inc	de
	jr	l8
;
br8:	ld	de,first_ent
l9:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br9
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	res	7,d
	ld	hl,first_ent - 1
	or	a
	sbc	hl,de
	jr	nc,ei10
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	res	7,(hl)
ei10:	pop	de
	inc	de
	jr	l9
;
br9:	ld	de,first_ent
l10:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br10
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	bit	7,(hl)
	jr	z,ei11
	ld	(hl),-1
	dec	hl
	ld	(hl),-1
ei11:	inc	de
	jr	l10
;
br10:	ld	de,first_ent
l11:	ld	hl,maxcmax
	or	a
	sbc	hl,de
	jr	z,br11
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	z,br11
	inc	de
	jr	l11
br11:	ld	(free_ent),de
	ret
;
loadfollowers:
	ld	hl,Slen + 255
	ld	b,0
lflp:	push	bc
	push	hl
	ld	a,6
	call	rdbybits
	pop	hl
	pop	de
	ld	(hl),a
	push	de
	push	hl
	dec	d
	ld	hl,followers
	call	shftadd
	ld	b,a
	or	a
	jr	z,nofoll
ldfllp:	push	hl
	push	bc
	ld	a,8
	call	rdbybits
	pop	bc
	pop	hl
	ld	(hl),a
	inc	hl
	djnz	ldfllp
nofoll:	pop	hl
	pop	bc
	dec	hl
	djnz	lflp
	ret
;
unreduce:
	push	af
; print method
	call	ilprt
	db	'Reduced ',0
; print version, date and time
	call	opver
	pop	af
	ld	e,a
	ld	d,0
	ld	hl,_L_table
	add	hl,de
	ld	a,(hl)
	ld	(L_table),a
	ld	hl,_D_shift
	add	hl,de
	ld	a,(hl)
	ld	(D_shift),a
	ld	a,1fh
	ld	(omask),a
	xor	a
	ld	(ExState),a
	ld	(lchar),a
	call	loadfollowers
ur1:	ld	a,(zipeof)	; test if eof reached
	and	1
	ret	nz
	call	slenlch
	or	a
	jr	nz,ur2
ur4:	ld	a,8
	call	rdbybits
	jr	ur3
;
ur2:	rd1bit
	dec	l
	jr	z,ur4
	call	slenlch
	dec	a
	or	1
	ld	l,a
	xor	a
btlp:	inc	a
	srl	l
	jr	nz,btlp
	call	readbits
	ld	de,followers
	add	hl,de
	ld	de,(lchar - 1)
	call	shftadd
	ld	a,(hl)
ur3:	ld	(nchar),a
	ld	l,a
	ld	a,(ExState)
	or	a
	jr	nz,ur5
	ld	a,l
	cp	DLE
	jr	nz,ur9
	ld	a,1
	ld	(ExState),a
	jr	ur6
;
ur5:	dec	a
	jr	nz,ur7
	ld	a,l
	or	a
	jr	z,ur10
	ld	(urV),a
	ld	a,(L_table)
	ld	h,a
	and	l
	cp	h
	ld	l,a
	ld	h,0
	ld	(Len),hl
	jr	nz,ur12
	ld	a,2
	jr	ur11
;
ur10:	ld	(ExState),a
	ld	a,DLE
ur9:	call	outb
	jr	ur6
;
ur7:	dec	a
	jr	nz,ur8
	ld	a,l
	ld	hl,Len
	add	a,(hl)
	ld	(hl),a
	jr	nc,ur12
	inc	hl
	inc	(hl)
ur12:	ld	a,3
	jr	ur11
;
ur8:	dec	a
	jr	nz,ur13
	ld	a,(D_shift)
	ld	b,a
	ld	a,(urV)
ur14:	srl	a
	djnz	ur14
	ld	h,a
	inc	hl
	ld	bc,(Len)
	inc	bc
	inc	bc
	inc	bc
	call	callback
ur13:	xor	a
ur11:	ld	(ExState),a
ur6:	ld	a,(nchar)
	ld	(lchar),a
	jp	ur1
;
slenlch:
	ld	hl,(lchar)
	ld	h,0
	ld	de,Slen
	add	hl,de
	ld	a,(hl)
	ret
;
shftadd:
	ld	e,0
	srl	d
	rr	e
	srl	d
	rr	e
	add	hl,de
	ret
;
callback:
	push	bc
	push	hl
	ld	hl,(outpos)
	ld	de,(outpos + 2)
	pop	bc
	or	a
	sbc	hl,bc
	jr	nc,cb2
	dec	de
cb2:	pop	bc
cb3:	bit	7,d
	jr	z,cb4
	ld	a,b
	or	c
	jr	z,cb4
	xor	a
	call	outbp
	inc	hl
	ld	a,h
	or	l
	jr	nz,cb5
	inc	de
cb5:	dec	bc
	jr	cb3
;
cb4:	ex	de,hl
cb6:	ld	a,b
	or	c
	ret	z
	ld	a,(omask)
	and	d
	ld	d,a
	ld	hl,outbuf
	add	hl,de
	ld	a,(hl)
	call	outbp
	inc	de
	dec	bc
	jr	cb6
;
outbp:	push	hl
	push	de
	push	bc
	call	outb
	pop	bc
	pop	de
	pop	hl
	ret
;
readlengths:
	ld	a,8
	call	rdbybits
	ld	d,h
	ld	e,d
	inc	hl
	ld	b,h
	ld	c,l
	ld	(ix + _maxlength),e
	ld	(ix + _maxlength + 1),d
	push	ix
	pop	hl
	inc	hl
	inc	hl
	inc	hl
rl1:	ld	a,b
	or	c
	ret	z
	push	bc
	push	de
	push	hl
	ld	a,4
	call	rdbybits
	inc	a
	push	af
	ld	a,4
	call	rdbybits
	inc	a
	ld	b,a
	pop	af
	ld	c,a
	pop	hl
	pop	de
	ld	a,(ix + _maxlength)
	cp	c
	jr	nc,rl2
	ld	(ix + _maxlength),c
rl2:	inc	hl
	inc	hl
	inc	hl
	ld	(hl),e
	inc	hl
	ld	(hl),c
	inc	e
	djnz	rl2
	pop	bc
	dec	bc
	jr	rl1
;
sortlengths:
	ld	h,(ix + _entries + 1)
	ld	l,(ix + _entries)
	ld	b,h
	ld	c,l
	ld	(entrs),hl
sl7:	srl	b
	rr	c
sl1:	ld	a,b
	or	c
	ret	z
	ld	(noswps),a
	push	ix
	ld	de,4
	add	ix,de
	push	ix
	pop	iy
	add	iy,bc
	add	iy,bc
	add	iy,bc
	add	iy,bc
	ld	hl,(entrs)
	or	a
	sbc	hl,bc
sl2:	ld	a,(ix + _bitlength)
	cp	(iy + _bitlength)
	jr	c,sl4
	jr	nz,sl3
	ld	a,(iy + _value)
	cp	(ix + _value)
	jr	nc,sl4
sl3:	ld	d,e
sl5:	ld	a,(ix)
	push	af
	ld	a,(iy)
	ld	(ix),a
	pop	af
	ld	(iy),a
	inc	ix
	inc	iy
	dec	d
	jr	nz,sl5
	ld	a,d
	ld	(noswps),a
	jr	sl6
;
sl4:	add	ix,de
	add	iy,de
sl6:	dec	hl
	ld	a,h
	or	l
	jr	nz,sl2
	pop	ix
	ld	a,(noswps)
	or	a
	jr	nz,sl7
	jr	sl1
;
generatetrees:
	ld	l,(ix + _entries)
	ld	h,(ix + _entries + 1)
	ld	c,l
	ld	b,h
	push	ix
	pop	de
	add	hl,hl
	add	hl,hl
	add	hl,de
	push	hl
	pop	iy
	xor	a
	ld	d,a
	ld	e,a
	ld	h,a
	ld	l,a
	ld	(lbl),a
gt1:	ld	a,b
	or	c
	ret	z
	dec	bc
	add	hl,de
	ld	a,(lbl)
	cp	(iy + _bitlength)
	jr	z,gt2
	ld	a,(iy + _bitlength)
	ld	(lbl),a
	sub	16
	ex	de,hl
	ld	hl,1
	jr	z,gt3
gt4:	add	hl,hl
	inc	a
	jr	nz,gt4
gt3:	ex	de,hl
gt2:	ld	(iy + _code),l
	ld	(iy + _code + 1),h
	push	de
	ld	de,-4
	add	iy,de
	pop	de
	jr	gt1
;
ldtrees:
	ld	a,(gpbf)
	rra
	ld	l,a
	and	1
	add	a,6
	ld	(dictb),a
	ld	a,l
	rra
	and	1
	ld	(ltp),a
	set	1,a
	ld	(mml),a
	ld	ix,lit_tree
	ld	hl,256
	call	nz,ld_tree
	ld	hl,64
	ld	ix,len_tree
	call	ld_tree
	ld	hl,64
	ld	ix,dist_tre
ld_tree:
	ld	(ix + _entries),l
	ld	(ix + _entries + 1),h
	call	readlengths
	call	sortlengths
	call	generatetrees
reversebits:
	push	ix
	pop	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
rb1:	inc	hl
	inc	hl
	inc	hl
	ld	c,(hl)
	ld	b,8
rb2:	srl	c
	adc	a,a
	djnz	rb2
	push	af
	inc	hl
	ld	c,(hl)
	ld	b,8
rb3:	srl	c
	adc	a,a
	djnz	rb3
	dec	hl
	ld	(hl),a
	pop	af
	inc	hl
	ld	(hl),a
	dec	de
	ld	a,d
	or	e
	jr	nz,rb1
	ret
;
readtree:
	push	ix
	pop	iy
	ld	de,4
	add	iy,de
	ld	b,d
	ld	e,d
	ld	h,d
	ld	l,d
rt1:	push	hl
	push	de
	push	bc
	rd1bit
	pop	af
	push	af
	or	a
	jr	z,rt2
rt3:	add	hl,hl
	dec	a
	jr	nz,rt3
rt2:	pop	bc
	pop	de
	add	hl,de
	ex	de,hl
	inc	b
	pop	hl
rt4:	ld	a,(iy + _bitlength)
	cp	b
	jr	nc,rt5
	push	de
	ld	de,4
	add	iy,de
	pop	de
	inc	hl
	ld	a,(ix + _entries)
	sub	l
	jr	nz,rt4
	ld	a,(ix + _entries + 1)
	sub	h
	jr	nz,rt4
rt6:	dec	a
	ret
;
rt5:	ld	a,(iy + _bitlength)
	cp	b
	jr	nz,rt1
	ld	a,(iy + _code)
	cp	e
	jr	nz,rt7
	ld	a,(iy + _code + 1)
	cp	d
	jr	nz,rt7
	ld	a,(iy + _value)
	ret
;
rt7:	push	de
	ld	de,4
	add	iy,de
	pop	de
	inc	hl
	ld	a,(ix + _entries)
	sub	l
	jr	nz,rt5
	ld	a,(ix + _entries + 1)
	sub	h
	jr	nz,rt5
	jr	rt6
;
unimplode:
; print method
	call	ilprt
	db	'Imploded',0
; print version, date and time
	call	opver
	ld	a,1fh
	ld	(omask),a
	call	ldtrees
ui1:	ld	a,(zipeof)	; test if eof
	and	1
	ret	nz
	inc	a
	call	readbits
	or	a
	jr	z,ui2
	ld	a,(ltp)
	or	a
	jr	z,ui3
	ld	ix,lit_tree
	call	readtree
	jr	ui4
;
ui3:	ld	a,8
	call	rdbybits
ui4:	call	outb
	jr	ui1
;
ui2:	ld	a,(dictb)
	call	readbits
	push	hl
	ld	ix,dist_tre
	call	readtree
	ld	l,a		;;v1.8-1 unimplode fix
	ld	h,0		;;v1.8-1
	ld	bc,(dictb - 1)
ui5:	add	hl,hl
	djnz	ui5
	pop	bc
	add	hl,bc
	push	hl
	ld	ix,len_tree
	call	readtree
	ld	l,a
	ld	h,0
	cp	63
	jr	nz,ui6
	push	hl
	ld	a,8
	call	rdbybits
	pop	de
	add	hl,de
ui6:	ld	de,(mml)
	ld	d,0
	add	hl,de
	ld	b,h
	ld	c,l
	pop	hl
	inc	hl
	call	callback
	jr	ui1
;
nextsymbol:
	ld	(treep),hl
nsloop:	push	hl
	rd1bit
	pop	hl
	or	a
	jr	z,nsleft
	inc	hl
	inc	hl
nsleft:	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	ld	a,d
	cp	10h
	jr	nc,nsleaf
	or	e
	ret	z

	ld	hl,(treep)
	add	hl,de
	add	hl,de
	add	hl,de
	add	hl,de
	jr	nsloop

nsleaf:	and	0fh
	ld	d,a
	ret
;
buildcode:
	ld	(lenp),hl
	ld	(nodes),de
	ld	(nrsym),bc

	ld	hl,blcnt
	ld	de,blcnt + 1
	ld	bc,2 * maxcl + 1
	ld	(hl),b
	ldir

	ld	bc,(nrsym)
	ld	de,(lenp)
bclp1:	ld	a,(de)
	add	a,a
	jr	z,bcnol
	ld	hl,blcnt
	add	a,l
	ld	l,a
	jr	nc,bcnc1
	inc	h
bcnc1:	ld	a,(hl)
	inc	a
	ld	(hl),a
	jr	nz,bcnol
	inc	hl
	inc	(hl)
bcnol:	inc	de
	dec	bc
	ld	a,b
	or	c
	jr	nz,bclp1

	ld	hl,0
	push	hl

	ld	bc,1
bclp2:	ld	a,c
	sub	maxcl + 1
	jr	nc,bccn2

	ld	hl,blcnt
	add	hl,bc
	add	hl,bc
	dec	hl
	ld	d,(hl)
	dec	hl
	ld	e,(hl)

	pop	hl
	add	hl,de
	add	hl,hl
	push	hl

	ex	de,hl
	ld	hl,ncode
	add	hl,bc
	add	hl,bc
	ld	(hl),e
	inc	hl
	ld	(hl),d

	inc	c
	jr	bclp2
bccn2:	pop	hl

	ld	hl,(nrsym)
	add	hl,hl
	add	hl,hl
	ld	b,h
	ld	c,l
	ld	hl,(nodes)
	ld	d,h
	ld	e,l
	inc	de
	dec	bc
	ld	(hl),0
	ldir

	ld	hl,1
	ld	(nnode),hl

	ld	bc,0
bclp3:	ld	hl,(lenp)
	add	hl,bc
	ld	a,(hl)
	or	a
	jr	z,bccn3

	push	bc

	push	af
	ld	hl,ncode
	add	a,a
	add	a,l
	ld	l,a
	jr	nc,bc4
	inc	h
bc4:	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	(bcode),de
	inc	de
	ld	(hl),d
	dec	hl
	ld	(hl),e
	pop	af

	ld	hl,1
bclp4:	dec	a
	or	a
	jr	z,bccn4
	add	hl,hl
	jr	bclp4
bccn4:	ld	(bmask),hl

	ld	hl,(nodes)
bclp5:	ld	de,(bcode)
	ld	bc,(bmask)
	ld	a,d
	and	b
	ld	d,a
	ld	a,e
	and	c
	ld	e,a
	or	d
	jr	z,bcleft
	inc	hl
	inc	hl
bcleft:	srl	b
	rr	c
	ld	(bmask),bc
	ld	a,b
	or	c
	jr	z,bccn5

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	a,d
	or	e
	jr	nz,bc6
	ld	de,(nnode)
	ld	(hl),d
	dec	hl
	ld	(hl),e
	inc	de
	ld	(nnode),de
	dec	de

bc6:	ld	hl,(nodes)
	add	hl,de
	add	hl,de
	add	hl,de
	add	hl,de
	jr	bclp5

bccn5:	pop	bc

	ld	(hl),c
	inc	hl
	ld	a,b
	or	10h
	ld	(hl),a

bccn3:	inc	bc
	ld	hl,(nrsym)
	or	a
	sbc	hl,bc
	jr	nz,bclp3
	ret
;
huffman:
	ld	a,5
	call	rdbybits
	inc	a
	ld	l,a
	ld	h,1
	ld	(hlit),hl

	ld	a,5
	call	rdbybits
	inc	a
	ld	(hdist),a

	ld	a,4
	call	rdbybits
	add	a,4
	ld	c,a

	ld	b,0
	ld	de,clord
hmlp1:	ld	a,b
	cp	c
	jr	nc,hmcn1
	push	bc
	push	de
	ld	a,3
	call	rdbybits
	pop	hl
	ld	c,(hl)
	ld	b,0
	ex	de,hl
	ld	hl,lenld
	add	hl,bc
	ld	(hl),a
	pop	bc
	inc	de
	inc	b
	jr	hmlp1

hmcn1:	xor	a
	ld	c,a
hmlp2:	ld	a,b
	cp	nrcl
	jr	nc,hmcn2
	ld	a,(de)
	ld	hl,lenld
	add	a,l
	ld	l,a
	jr	nc,hmnc2
	inc	h
hmnc2:	ld	(hl),c
	inc	de
	inc	b
	jr	hmlp2

hmcn2:	ld	hl,lenld
	ld	de,cltr
	ld	bc,nrcl
	call	buildcode

	ld	hl,(hlit)
	ld	a,(hdist)
	add	a,l
	ld	c,a
	ld	a,h
	adc	a,0
	ld	b,a
	ld	hl,lenld
hmlp3:	push	bc
	push	hl
	ld	hl,cltr
	call	nextsymbol
	ld	a,e

	cp	010h
	jr	nz,hmn16
	ld	a,2
	call	rdbybits
	pop	hl
	pop	bc
	add	a,3
	ld	d,a
	dec	hl
	ld	e,(hl)
	inc	hl
hmlp4:	ld	(hl),e
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp4
	jr	hmcn3

hmn16:	cp	011h
	jr	nz,hmn17
	ld	a,3
	call	rdbybits
	pop	hl
	pop	bc
	add	a,3
	ld	d,a
	xor	a
hmlp5:	ld	(hl),a
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp5
	jr	hmcn3

hmn17:	cp	012h
	jr	nz,hmn18
	ld	a,7
	call	rdbybits
	pop	hl
	pop	bc
	add	a,11
	ld	d,a
	xor	a
hmlp6:	ld	(hl),a
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp6
	jr	hmcn3

hmn18:	pop	hl
	pop	bc
	ld	(hl),a
	inc	hl
	dec	bc

hmcn3:	ld	a,b
	or	c
	jr	nz,hmlp3

	ld	hl,lenld
	ld	de,littr
	ld	bc,(hlit)
	call	buildcode

	ld	hl,(hlit)
	ld	de,lenld
	add	hl,de
	ld	de,disttr
	ld	a,(hdist)
	ld	c,a
	ld	b,0
	call	buildcode

	ld	hl,(inbps)		; saved input buffer addr
	ld	a,l
	or	h
	jr	z,hmnext
; restore state input control block
	ld	hl,fxget		; restore input routine addr
	ld	(getadr),hl
; restore bit pointers
	ld	a,(blfts)
	ld	(bleft),a		; restore bit pointer
	ld	a,(bitbs)
	ld	(bitbuf),a		; restore bit buffer addr
;
	ld	hl,counting
	inc	(hl)			; resume counting bytes read

hmnext:	ld	hl,littr
	call	nextsymbol
	ld	a,d
	dec	a
	or	e
	ret	z
	ld	a,(zipeof)	; test if eof
	and	1
	ret	nz

	ld	a,d
	or	a
	jr	nz,hmsym
	ld	a,e
	call	outb
	jr	hmnext

hmsym:	dec	e
	ld	d,0
	ld	hl,lenex
	add	hl,de
	ld	a,(hl)
	ld	hl,0
	or	a
	jr	z,hmnlen
	push	de
	call	readbits
	pop	de
hmnlen:	push	hl
	ld	hl,lenbas
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	add	hl,de
	push	hl

	ld	hl,disttr
	call	nextsymbol
	ld	hl,dstex
	add	hl,de
	ld	a,(hl)
	ld	hl,0
	or	a
	jr	z,hmndst
	push	de
	call	readbits
	pop	de
hmndst:	push	hl
	ld	hl,dstbas
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	add	hl,de

	pop	bc
	call	callback
	jr	hmnext
;
undeflate:
; print method
	call	ilprt
	db	'Deflated',0
; print version, date and time
	call	opver
	ld	a,7fh
	ld	(omask),a

udloop:	ld	a,(zipeof)	; test if eof
	and	1
	ret	nz

	rd1bit
	push	af

	ld	a,2
	call	rdbybits
	or	a
	jr	nz,udnt0

	xor	a
	ld	(bleft),a
	ld	a,16
	call	readbits
	push	hl
	ld	a,16
	call	readbits
	pop	bc
	scf
	adc	hl,bc
	jr	nz,udblm

udt0lp:	ld	a,b
	or	c
	jr	z,udnext
	ld	a,(zipeof)	; test if eof
	and	1
	jr	nz,udpret
	push	bc
	call	getbyte
	call	outb
	pop	bc
	dec	bc
	jr	udt0lp

udnt0:	dec	a
	jr	nz,udnt1
; switch input to read from static_pre table
	ld	hl,rdstat		; addr of input routine
	ld	(getadr),hl		; save it in call instrution
	ld	hl,static_pre		; addr of next byte to read
	ld	(inbps),hl		; save it
; save bit pointers
	ld	a,(bleft)		; save bit pointer
	ld	(blfts),a
	ld	a,(bitbuf)		; save bit buffer addr
	ld	(bitbs),a
;
	ld	hl,counting		; stop counting bytes read
	dec	(hl)
;
	xor	a			; reset bit read offset
	ld	(bleft),a
	call	huffman
	jr	udnext

udnt1:	dec	a
	jr	nz,udubt
	ld	hl,0			; clear input addr pointer 
	ld	(inbps),hl
	call	huffman

udnext:	pop	af
	or	a
	jp	z,udloop
	ret

udpret:	pop	af
	ret
udbskp:	ld	a,(zipeof)	; test if eof
	and	1
	jr	nz,udpret
	call	getbyte
	jr	udbskp
udblm:	call	ilprt
	db	'Block length mismatch',CR,LF,0
	jr	udbskp
udubt:	call	ilprt
	db	'Unknown block type',CR,LF,0
	jr	udbskp
;
; ckcon -- checks console for character; aborts if ^C
; Only really checks every conckct calls, it is called
; from getbyte for every input byte.
;
ckcon:	ld	hl,conckct
	dec	(hl)		; decrement console check counter
	ld	a,(hl)
	and	7fh
	ret	nz		; only check every 128 calls
	ld	e,0FFh		; check for character
	ld	c,dircon
	call	bdos
	or	a
	ret	z
	cp	CtrlC		; ^C ?
	ret	nz		; (no, continue)
	ld	a,(opnflg)	; is a file open?
	or	a
	jr	z,ckcon1	; (no)
ckcon0:	call	setout
	ld	de,opfcb
	 if SLRlibs
	call	f$close		; close it
	call	f$delete	; and delete it
	 else
	call	f$clos		; close it
	call	f$dele		; and delete it
	 endif
	call	ilprt
	db	'Partial file erased -- ',0
ckcon1:	call	ilprt
	db	'Aborted',0
	jp	clsxit
;
; getusr -- stuffs current user into default FCBs if not ZCPR3 (for Z3LOG)
;
getusr:	ld	hl,(Z3EAdr)	; ZCPR3?
	ld	a,h
	or	l
	ret	nz		; (yes, skip this)
	ld	c,setusr
	ld	e,0ffh
	call	bdos
	ld	(dfcb+13),a
	ld	(altfcb+13),a
	ret
;
; setout -- set output drive/user
;
setout:	ld	de,altfcb
	jp	z3log
;
; usage -- show syntax for ZCPR3 ("dir:") or vanilla CP/M ("d:")
;
usage:	call	ilprt
	db	'Usage:',CR,LF
	db	'   UNZIP {d',0
	ld	hl,(Z3EAdr)
	ld	a,h
	or	l
	push	af
	jr	z,usage2
	call	ilprt
	db	'ir',0
usage2:	call	ilprt
	db	':}zipfile {d',0
	pop	af
	jr	z,usage3
	call	ilprt
	db	'ir',0
usage3:	call	ilprt
	db	':}{afn.typ}',CR,LF
	db	'If a destination is given, files are extracted.',CR,LF
	db	'If not, filenames are listed.',0
	jp	exit
;
; opsiz - output uncompressed and compressed file size as 7 
;		blank filled digits
opsiz:
; First print uncompressed size
	call	ilprt
	db	' ',0
	ld	hl,ucs
	ld	a,7
	call	plwdc
	call	ilprt
	db	' ',0
;
; now output compressed file size as 7 blank filled digits
	ld	hl,cs
	ld	a,7
	call	plwdc
	call	ilprt
	db	' ',0
	ret
;
; opver - output zip version
;
opver:
	call	ilprt
	db	'  ',0
	ld	hl,(lfh)
	call	phl2dc
	call	ilprt
	db	'  ',0
;	ret
;
; opdat - output date and time
;
opdat:
; First convert date from MSDOS to universal format
	ld	hl,(lmfd)	; HL<-modify date
	ld	de,dsbuf	; put date stamp here
	call	dcvt		; date now in create buffer
; Then convert time from MSDOS to universal format
	ld	hl,(lmft)	; get modify time
	call	tcvt		; time now in create stamp
; print date as day then month 
	ld	a,0ffh		; choose day then month
	ld	hl,dsbuf
	call	pdats2		; print date
	call	ilprt
	db	'  ',0
; print time in military format
	ld	a,0ffh		; choose military format
	ld	hl,dsbuf	; point to BCD date sting
	call	ptims1		; print time
	call	ilprt
	db	' ',0
; print 32 bit CRC as 8 hex digits (assume CRC stored little endian)
	ld	hl,(crc+2)	; most significant 16 bits
	call	PHL4HC		; print as 4 hex digits
	ld	hl,(crc)	; least significant 16 bits
	call	PHL4HC
	call	ilprt
	db	'  ',0
	ret
;
; dcvt - convert MS-DOS date to DateStamper format
;   Enter:  	HL = MS-DOS formatted date word
;		DE = Pointer to storage buffer in DE. 
;
; MS-DOS 16-bit date format:
; Bits [15:9] = year - 1980
; Bits	[8:5] = month of year
; Bits	[4:0] = day of month
;
dcvt:
; shift HL right one bit so HL has year and month in high order
; bits of L
	ld	c,l		; save L
	srl	h		; Shift H right, LSB to carry
	rr	l		; Shift L right, carry to MSB
	ld	a,h
	sub	20		; try 2000 and greater
	jr	nc,y2k
	add	80+20		; 80 to 99
y2k:	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
; shift month to bits [3:0] of L
	SRL	L		; Shift L right, carry ignored
	SRL	L		; Shift L right, carry ignored
	SRL	L		; Shift L right, carry ignored
	SRL	L		; month now in L 
	ld	a,l
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ld	a,c		; get day
	and	1Fh
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ret
;
; tcvt - Convert time from MS-DOS to DateStamper format and save in 
; storage buffer.  Seconds not converted.
;   Enter:  	HL = MS-DOS formatted time word
;		DE = Pointer to storage buffer in DE. 
;
; MS-DOS 16-bit packed binary time format
;    Bits	[15:11] = hours
;    Bits	[10:5]  = minutes
;    Bits	[4:0]   = seconds/2
;
tcvt:	ld	b,3		; Loop counter for shifting
tcvtlp:	srl	h		; Shift H right, LSB to carry
	rr	l		; Shift L right, carry to MSB
	djnz	tcvtlp		; Repeat 3 times. when done, hours in H
	SRL	L		; Shift L right, carry ignored
	srl	l		; Now have minutes in L
	ld	A,H		; Get hours in A
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ld	a,l		; Now do minutes
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
;	inc	de		; Advance pointer
	ret
;
; Convert BIN to BCD
; Enter: A = Binary number to be converted
; Exit : A = Two BCD digits
;		 All registers preserved
;
BINBCD: OR	A
	RET	Z		; Zero is same
	PUSH	BC		; Save register
	LD	B,A		; Set counter
	XOR	A
BCDLP:	INC	A		; Count up BCD..
	DAA
	DJNZ	BCDLP		; ..til all gone
	POP	BC
	RET
;
; data storage . . .
;
init:
	db	0	; for bleft
	db	0	; for wrtpt was 1
	dw	0,0	; for outpos
	dw	-1,-1	; for crc32
endinit:
dsbuf:	db	0,0,0,0,0
;inbufp:	dw	0080h	; points input buffer
;readpt:	db	80h	; offset to next byte in input buffer
omask:	db	1fh
_L_table:
	db	7fh, 3fh, 1fh, 0fh
_D_shift:
	db	07h, 06h, 05h, 04h
clord:	db	16, 17, 18
	db	0, 8
	db	7, 9
	db	6, 10
	db	5, 11
	db	4, 12
	db	3, 13
	db	2, 14
	db	1, 15
lenbas:	dw	3, 4
	dw	5, 6
	dw	7, 8
	dw	9, 10
	dw	11, 13
	dw	15, 17
	dw	19, 23
	dw	27, 31
	dw	35, 43
	dw	51, 59
	dw	67, 83
	dw	99, 115
	dw	131, 163
	dw	195, 227
	dw	258
lenex:	db	0, 0
	db	0, 0
	db	0, 0
	db	0, 0
	db	1, 1
	db	1, 1
	db	2, 2
	db	2, 2
	db	3, 3
	db	3, 3
	db	4, 4
	db	4, 4
	db	5, 5
	db	5, 5
	db	0
dstbas:	dw	1, 2
	dw	3, 4
	dw	5, 7
	dw	9, 13
	dw	17, 25
	dw	33, 49
	dw	65, 97
	dw	129, 193
	dw	257, 385
	dw	513, 769
	dw	1025, 1537
	dw	2049, 3073
	dw	4097, 6145
	dw	8193, 12289
	dw	16385, 24577
dstex:	db	0, 0
	db	0, 0
	db	1, 1
	db	2, 2
	db	3, 3
	db	4, 4
	db	5, 5
	db	6, 6
	db	7, 7
	db	8, 8
	db	9, 9
	db	10, 10
	db	11, 11
	db	12, 12
	db	13, 13
static_pre:
	db	0ffh, 05bh, 000h, 06ch, 003h, 036h, 0dbh, 0b6h
	db	06dh, 0dbh, 0b6h, 06dh, 0dbh, 0b6h, 0cdh, 0dbh
	db	0b6h, 06dh, 0dbh, 0b6h, 06dh, 0dbh, 0a8h, 06dh
	db	0ceh, 08bh, 06dh, 03bh
$memry:	dw	0
crc32tab:	; crc32_tab[] from degzip_portable.c, takes 1k
	db	000h,000h,000h,000h,096h,030h,007h,077h
	db	02Ch,061h,00Eh,0EEh,0BAh,051h,009h,099h
	db	019h,0C4h,06Dh,007h,08Fh,0F4h,06Ah,070h
	db	035h,0A5h,063h,0E9h,0A3h,095h,064h,09Eh
	db	032h,088h,0DBh,00Eh,0A4h,0B8h,0DCh,079h
	db	01Eh,0E9h,0D5h,0E0h,088h,0D9h,0D2h,097h
	db	02Bh,04Ch,0B6h,009h,0BDh,07Ch,0B1h,07Eh
	db	007h,02Dh,0B8h,0E7h,091h,01Dh,0BFh,090h
	db	064h,010h,0B7h,01Dh,0F2h,020h,0B0h,06Ah
	db	048h,071h,0B9h,0F3h,0DEh,041h,0BEh,084h
	db	07Dh,0D4h,0DAh,01Ah,0EBh,0E4h,0DDh,06Dh
	db	051h,0B5h,0D4h,0F4h,0C7h,085h,0D3h,083h
	db	056h,098h,06Ch,013h,0C0h,0A8h,06Bh,064h
	db	07Ah,0F9h,062h,0FDh,0ECh,0C9h,065h,08Ah
	db	04Fh,05Ch,001h,014h,0D9h,06Ch,006h,063h
	db	063h,03Dh,00Fh,0FAh,0F5h,00Dh,008h,08Dh
	db	0C8h,020h,06Eh,03Bh,05Eh,010h,069h,04Ch
	db	0E4h,041h,060h,0D5h,072h,071h,067h,0A2h
	db	0D1h,0E4h,003h,03Ch,047h,0D4h,004h,04Bh
	db	0FDh,085h,00Dh,0D2h,06Bh,0B5h,00Ah,0A5h
	db	0FAh,0A8h,0B5h,035h,06Ch,098h,0B2h,042h
	db	0D6h,0C9h,0BBh,0DBh,040h,0F9h,0BCh,0ACh
	db	0E3h,06Ch,0D8h,032h,075h,05Ch,0DFh,045h
	db	0CFh,00Dh,0D6h,0DCh,059h,03Dh,0D1h,0ABh
	db	0ACh,030h,0D9h,026h,03Ah,000h,0DEh,051h
	db	080h,051h,0D7h,0C8h,016h,061h,0D0h,0BFh
	db	0B5h,0F4h,0B4h,021h,023h,0C4h,0B3h,056h
	db	099h,095h,0BAh,0CFh,00Fh,0A5h,0BDh,0B8h
	db	09Eh,0B8h,002h,028h,008h,088h,005h,05Fh
	db	0B2h,0D9h,00Ch,0C6h,024h,0E9h,00Bh,0B1h
	db	087h,07Ch,06Fh,02Fh,011h,04Ch,068h,058h
	db	0ABh,01Dh,061h,0C1h,03Dh,02Dh,066h,0B6h
	db	090h,041h,0DCh,076h,006h,071h,0DBh,001h
	db	0BCh,020h,0D2h,098h,02Ah,010h,0D5h,0EFh
	db	089h,085h,0B1h,071h,01Fh,0B5h,0B6h,006h
	db	0A5h,0E4h,0BFh,09Fh,033h,0D4h,0B8h,0E8h
	db	0A2h,0C9h,007h,078h,034h,0F9h,000h,00Fh
	db	08Eh,0A8h,009h,096h,018h,098h,00Eh,0E1h
	db	0BBh,00Dh,06Ah,07Fh,02Dh,03Dh,06Dh,008h
	db	097h,06Ch,064h,091h,001h,05Ch,063h,0E6h
	db	0F4h,051h,06Bh,06Bh,062h,061h,06Ch,01Ch
	db	0D8h,030h,065h,085h,04Eh,000h,062h,0F2h
	db	0EDh,095h,006h,06Ch,07Bh,0A5h,001h,01Bh
	db	0C1h,0F4h,008h,082h,057h,0C4h,00Fh,0F5h
	db	0C6h,0D9h,0B0h,065h,050h,0E9h,0B7h,012h
	db	0EAh,0B8h,0BEh,08Bh,07Ch,088h,0B9h,0FCh
	db	0DFh,01Dh,0DDh,062h,049h,02Dh,0DAh,015h
	db	0F3h,07Ch,0D3h,08Ch,065h,04Ch,0D4h,0FBh
	db	058h,061h,0B2h,04Dh,0CEh,051h,0B5h,03Ah
	db	074h,000h,0BCh,0A3h,0E2h,030h,0BBh,0D4h
	db	041h,0A5h,0DFh,04Ah,0D7h,095h,0D8h,03Dh
	db	06Dh,0C4h,0D1h,0A4h,0FBh,0F4h,0D6h,0D3h
	db	06Ah,0E9h,069h,043h,0FCh,0D9h,06Eh,034h
	db	046h,088h,067h,0ADh,0D0h,0B8h,060h,0DAh
	db	073h,02Dh,004h,044h,0E5h,01Dh,003h,033h
	db	05Fh,04Ch,00Ah,0AAh,0C9h,07Ch,00Dh,0DDh
	db	03Ch,071h,005h,050h,0AAh,041h,002h,027h
	db	010h,010h,00Bh,0BEh,086h,020h,00Ch,0C9h
	db	025h,0B5h,068h,057h,0B3h,085h,06Fh,020h
	db	009h,0D4h,066h,0B9h,09Fh,0E4h,061h,0CEh
	db	00Eh,0F9h,0DEh,05Eh,098h,0C9h,0D9h,029h
	db	022h,098h,0D0h,0B0h,0B4h,0A8h,0D7h,0C7h
	db	017h,03Dh,0B3h,059h,081h,00Dh,0B4h,02Eh
	db	03Bh,05Ch,0BDh,0B7h,0ADh,06Ch,0BAh,0C0h
	db	020h,083h,0B8h,0EDh,0B6h,0B3h,0BFh,09Ah
	db	00Ch,0E2h,0B6h,003h,09Ah,0D2h,0B1h,074h
	db	039h,047h,0D5h,0EAh,0AFh,077h,0D2h,09Dh
	db	015h,026h,0DBh,004h,083h,016h,0DCh,073h
	db	012h,00Bh,063h,0E3h,084h,03Bh,064h,094h
	db	03Eh,06Ah,06Dh,00Dh,0A8h,05Ah,06Ah,07Ah
	db	00Bh,0CFh,00Eh,0E4h,09Dh,0FFh,009h,093h
	db	027h,0AEh,000h,00Ah,0B1h,09Eh,007h,07Dh
	db	044h,093h,00Fh,0F0h,0D2h,0A3h,008h,087h
	db	068h,0F2h,001h,01Eh,0FEh,0C2h,006h,069h
	db	05Dh,057h,062h,0F7h,0CBh,067h,065h,080h
	db	071h,036h,06Ch,019h,0E7h,006h,06Bh,06Eh
	db	076h,01Bh,0D4h,0FEh,0E0h,02Bh,0D3h,089h
	db	05Ah,07Ah,0DAh,010h,0CCh,04Ah,0DDh,067h
	db	06Fh,0DFh,0B9h,0F9h,0F9h,0EFh,0BEh,08Eh
	db	043h,0BEh,0B7h,017h,0D5h,08Eh,0B0h,060h
	db	0E8h,0A3h,0D6h,0D6h,07Eh,093h,0D1h,0A1h
	db	0C4h,0C2h,0D8h,038h,052h,0F2h,0DFh,04Fh
	db	0F1h,067h,0BBh,0D1h,067h,057h,0BCh,0A6h
	db	0DDh,006h,0B5h,03Fh,04Bh,036h,0B2h,048h
	db	0DAh,02Bh,00Dh,0D8h,04Ch,01Bh,00Ah,0AFh
	db	0F6h,04Ah,003h,036h,060h,07Ah,004h,041h
	db	0C3h,0EFh,060h,0DFh,055h,0DFh,067h,0A8h
	db	0EFh,08Eh,06Eh,031h,079h,0BEh,069h,046h
	db	08Ch,0B3h,061h,0CBh,01Ah,083h,066h,0BCh
	db	0A0h,0D2h,06Fh,025h,036h,0E2h,068h,052h
	db	095h,077h,00Ch,0CCh,003h,047h,00Bh,0BBh
	db	0B9h,016h,002h,022h,02Fh,026h,005h,055h
	db	0BEh,03Bh,0BAh,0C5h,028h,00Bh,0BDh,0B2h
	db	092h,05Ah,0B4h,02Bh,004h,06Ah,0B3h,05Ch
	db	0A7h,0FFh,0D7h,0C2h,031h,0CFh,0D0h,0B5h
	db	08Bh,09Eh,0D9h,02Ch,01Dh,0AEh,0DEh,05Bh
	db	0B0h,0C2h,064h,09Bh,026h,0F2h,063h,0ECh
	db	09Ch,0A3h,06Ah,075h,00Ah,093h,06Dh,002h
	db	0A9h,006h,009h,09Ch,03Fh,036h,00Eh,0EBh
	db	085h,067h,007h,072h,013h,057h,000h,005h
	db	082h,04Ah,0BFh,095h,014h,07Ah,0B8h,0E2h
	db	0AEh,02Bh,0B1h,07Bh,038h,01Bh,0B6h,00Ch
	db	09Bh,08Eh,0D2h,092h,00Dh,0BEh,0D5h,0E5h
	db	0B7h,0EFh,0DCh,07Ch,021h,0DFh,0DBh,00Bh
	db	0D4h,0D2h,0D3h,086h,042h,0E2h,0D4h,0F1h
	db	0F8h,0B3h,0DDh,068h,06Eh,083h,0DAh,01Fh
	db	0CDh,016h,0BEh,081h,05Bh,026h,0B9h,0F6h
	db	0E1h,077h,0B0h,06Fh,077h,047h,0B7h,018h
	db	0E6h,05Ah,008h,088h,070h,06Ah,00Fh,0FFh
	db	0CAh,03Bh,006h,066h,05Ch,00Bh,001h,011h
	db	0FFh,09Eh,065h,08Fh,069h,0AEh,062h,0F8h
	db	0D3h,0FFh,06Bh,061h,045h,0CFh,06Ch,016h
	db	078h,0E2h,00Ah,0A0h,0EEh,0D2h,00Dh,0D7h
	db	054h,083h,004h,04Eh,0C2h,0B3h,003h,039h
	db	061h,026h,067h,0A7h,0F7h,016h,060h,0D0h
	db	04Dh,047h,069h,049h,0DBh,077h,06Eh,03Eh
	db	04Ah,06Ah,0D1h,0AEh,0DCh,05Ah,0D6h,0D9h
	db	066h,00Bh,0DFh,040h,0F0h,03Bh,0D8h,037h
	db	053h,0AEh,0BCh,0A9h,0C5h,09Eh,0BBh,0DEh
	db	07Fh,0CFh,0B2h,047h,0E9h,0FFh,0B5h,030h
	db	01Ch,0F2h,0BDh,0BDh,08Ah,0C2h,0BAh,0CAh
	db	030h,093h,0B3h,053h,0A6h,0A3h,0B4h,024h
	db	005h,036h,0D0h,0BAh,093h,006h,0D7h,0CDh
	db	029h,057h,0DEh,054h,0BFh,067h,0D9h,023h
	db	02Eh,07Ah,066h,0B3h,0B8h,04Ah,061h,0C4h
	db	002h,01Bh,068h,05Dh,094h,02Bh,06Fh,02Ah
	db	037h,0BEh,00Bh,0B4h,0A1h,08Eh,00Ch,0C3h
	db	01Bh,0DFh,005h,05Ah,08Dh,0EFh,002h,02Dh
;
; uninitialized storage
;
	dseg

oldstk:	ds	2
mode:	ds	1
zipeof:	ds	1		; eof flag, odd=>set, even=>clear
counting:			; must follow zipeof - don't move
	ds	1
junk:	ds	STRSIZ
lfh:				; data read from local file header
vnte:	ds	2		; PKZIP version
gpbf:	ds	2		; general purpose bit flag
cm:	ds	2		; compression method
lmft:	ds	2		; file last modification time
lmfd:	ds	2		; file last modification date
crc:	ds	4		; CRC-32 of uncompressed data
cs:	ds	4		; compressed size
ucs:	ds	4		; uncompressed size
fnl:	ds	2		; file name length
efl:	ds	2		; extra field length
endlfh:	ds	1		; marker for end of lfh data; also,
				; zero byte is written here by getstring
; Input Control Block for byte oriented file read
icb:	ds	1	;Number of 128-byte records in buffer (set by user)	
	ds	2	;Drive and user (set and used by ZFXIO)
	ds	1	;End of file flag (set and used by ZFXIO)
ipcnt:	ds	2	;Byte counter (set and used by ZFXIO)
ipbp:	ds	2	;Pointer to next byte (set and used by ZFXIO)
ipbuf:	ds	2	;Address of working buffer (set by user)
infcb:	ds	36	; input file control block
; Output Control Block for byte oriented file read
ocb:	ds	8
opbuf:	ds	2
opfcb:	ds	1		; output file control block
opfn:	ds	8
opext:	ds	3
	ds	24
mtchfcb:
	ds	11
; note that as indicated above, bitbuf must be the byte before bleft
bitbuf:	ds	1
vars:
bleft:	ds	1
	ds	1
outpos:	ds	4
crc32:	ds	4
curmode:
	ds	1
opnflg:	ds	1
conckct:
	ds	1
L_table:
	ds	1
D_shift:
	ds	1
urV:	ds	1
nchar:	ds	1
lchar:	ds	1
ExState:
	ds	1
Len:	ds	2
ltp:	ds	1
mml:	ds	1
dictb:	ds	1
noswps:	ds	1
entrs:	ds	2
lbl:	ds	1
treep:	ds	2
lenp:	ds	2
nodes:	ds	2
nrsym:	ds	2
nnode:	ds	2
bcode:	ds	2
bmask:	ds	2
blcnt:	ds	2 * maxcl + 2
ncode:	ds	2 * maxcl + 2
hlit:	ds	2
hdist:	ds	1
inbps:	ds	2
;rdpts:	ds	2
;incnt:	ds	2
bitbs:	ds	1
blfts:	ds	1
oldcode:
	ds	2
offset:	ds	2
codesize:
	ds	1
maxcode:
	ds	2
free_ent:
	ds	2
finchar:
	ds	1
stackp:	ds	2
incode:	ds	2
code:	ds	2
outbuf:
suffix_of:
	ds	8192
prefix_of:
Slen:
lit_tree:
	ds	_sf_tree_
len_tree:
	ds	_sf_tree_
dist_tre:
	ds	_sf_tree_
	ds	16384 + 2 - (3 * _sf_tree_)
followers:
	ds	8192
stack	equ	$
lenld:	ds	nrlit + nrdist
cltr:	ds	4 * nrcl
littr:	ds	4 * nrlit
disttr:	ds	4 * nrdist
endtr:
	ds	8192 + 2 - (endtr - lenld)
	ds	60
locstk	equ	$

	end
