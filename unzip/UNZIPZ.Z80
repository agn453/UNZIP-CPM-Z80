; UNZIPZ.Z80
;
;		Z-System UNZIPPER
;	Dissolves all MS-DOS Zip files
;
Vers	equ	03
Revisn	equ	2		;;v0.3-2
;
; Version 0.3-2 -- September 3, 2020 -- Martin and Lars
;	Major & minor Improvments plus bug fixes.
;	Fixed long filename problem due to directory paths in the filename
;	Added a local stack pointer.
;	Added the UnDeflate algorithm (based on the work by
;	Keir Fraser's HiTech-C code at
;	https://github.com/keirf/Amiga-Stuff/blob/master/inflate/degzip_portable.c
;
; Version 0.3-1 -- June 17, 2020 -- Martin
;
;	In postings to the USENET newgroup comp.os.cpm, a flaw in both
;	the un-implode and un-shrink routines was found to be causing
;	CRC errors.
;
;	For un-implode, the algorithm is essentially a translation
;	of the PKZ101 MS-DOS algorithm in C that has been hand optimized
;	into Z80 assembly language.  However, the readtree() function
;	was incorrectly returning a byte value in the A register, when
;	the shift routine at label ui5 was expecting a 16-bit value in HL.
;
;	For unshrink, there is a race condition with handling the "KwKwK"
;	case that was omitted from the routine.
;
;	Both updates are flagged with ;;v1.5-1 comments, and the
;	version sign-on message now includes the revision.
;
; Version 0.2-0 UNZIPZ -- 4/25/91 -- Simeon Cran
;
;The files in this archive are my Z-modified version of UNZIP 1.2.  
;by David P. Goodenough.  They consist of three files in order to 
;make sure that the unitialised data ends up at the end of all files 
;linked.  Also, because the unitialised data file (UDATZI.Z80) 
;needed to share some equates with the main program, all equates 
;have been put in a separate .LIB file.
;
	.request	udatzi	
	extrn	IPuser,OPuser
	extrn	mode,junk,lfh,gpbf,cm,lmft
	extrn	lmfd,crc,cs,ucs,fnl,efl
	extrn	endlfh,lfhsiz,opfcb,opfn,opext,bitbuf,vars
	extrn	bleft,wrtpt,outpos,crc32,curmode,opbuf
	extrn	L_table,D_shift,V,nchar,lchar,ExState
	extrn	Len,ltp,mml,dictb,noswps,entrs
;	extrn	lbl,oldcode,offset,codesize,maxcode,free_ent
	extrn	lbl,treep,lenp,nodes,nrsym,nnode,bcode,bmask
	extrn	lenld,cltr,littr,disttr,bitbs,blfts
	extrn	oldcode,offset,codesize,maxcode,free_ent
	extrn	blcnt,ncode,hlit,hdist,inbps,rdpts
	extrn	finchar,stackp,incode,code,outbuf,suffix_of
	extrn	prefix_of,Slen,lit_tree,len_tree,dist_tre,followers,stack
	extrn	fcb2sav,eodata,locstk,nomtch
;					
	.request	zslib
	extrn	sstpcp,pdats2,ptims1,plwdc,GUA,SUA
;
	.request	z3lib
;
	.request	syslib
	extrn	INITFC,SETDMA,PHL4HC,pafdc,PFN1,PFN2,cout
;
	.request	vlib	
	extrn	Z3VINIT
;	extrn	Z3VINI
	extrn	vpstr,vprint
;
	.request	dslib
	extrn	timini,pstamp,DOSTYP,TIMTYP
	extrn	@BDOS,CAPS
	global	ENVPTR

;	.in		unzipequ 
	maclib		unzipequ.lib
	
	jp	start
	db	'Z3ENV'
	db	3
ENVPTR:	dw	0
	dw	100h
zflag:	db	0FFh

usage:	db	'Syntax:  ',1,'UNZIP [du:]ufn[.ZIP][ du:][afn ][/o]',CR,LF
	db	'If no option specified, UNZIP checks the CRC of the files.',CR,LF
	db	'Options: E - extract files.',CR,LF,0

start:	ld	sp,locstk
	ld	hl,(bdos+1)
	ld	de,-128
	add	hl,de
	ld	de,eodata
	ccf
	sbc	hl,de
	jr	nc,nufram
	call	vprint
	db	'Not enough memory -- aborting',CR,LF,0
	rst	0
nufram:	call	timini		; check for datestamping support
	; Global variables returned:
	; DOSTYP ='S'=>ZSDOS, 'D'=>Datestamper & '3'=>CP/M Plus.
	;    0=>no datestamping
	; DOSVER has version number, 22=>CP/M 2.2 and
	; compatiblle. 
	ld	hl,eodata
	call	PHL4HC
	call	crlf
	ld	de,ENVPTR
	ld	a,d
	or	e
	jr	nz,strt
	xor	a		; not running zsystem
	ld	(zflag),a
strt:
	call	z3vinit		
	call	vprint
	db	'UNZIPZ  Version '
	db	Vers/10+'0','.',Vers mod 10+'0'
	db	'-',Revisn mod 10+'0'
	db	' - SC',CR,LF,LF,0
	ld	hl,(5dh)
	or	a
	ld	de,['/' SHL 8]+'/'
	sbc	hl,de
	jr	nz,notHELP
help:	ld	hl,usage
	call	vpstr
	jp	exit
		
notHELP:
	ld	a,(infcb+1)	
	cp	' '
	jr	z,HELP		
	ld	a,(infcb+13)	
	ld	(IPuser),a	
	ld	a,(fcb2+13)	
	ld	(OPuser),a	
	ld	hl,fcb2
	ld	a,(hl)		
	ld	(opfcb),a	
	inc	hl
	ld	bc,11
	ld	de,fcb2sav
	ldir
	ld	a,(fcb2+1)	
	cp	'/'		
	jr	z,nofspec	
	cp	' '
	jr	nz,notall
nofspec:
; set default to match all, ie fill out fcb filename with '?'	
	ld	bc,10
	ld	hl,fcb2sav
	ld	de,fcb2sav+1	
	ld	(hl),'?'
	ldir			
notall:	ld	a,(80h)		
	ld	b,a
	ld	hl,81h
	ld	a,'/'
optLOOP:
	inc	hl
	cp	(hl)
	jr	z,OPTIONfnd
	djnz	optLOOP
	jr	noOPT

OPTIONfnd:
	inc	hl
	ld	a,(hl)
	sub	EXTRACT
	jr	z,setOPT
	djnz	OPTIONfnd
noOPT:	or	1
setOPT:	ld	(mode),a		;mode=0 => extract file
	ld	a,(065h)
	cp	' '
	jr	nz,wasext
	ld	hl,['I' SHL 8] + 'Z'
	ld	(065h),hl
	ld	a,'P'
	ld	(067h),a
wasext:
	call	vprint
	db	'ZIP archive  = ',0
	ld	a,(INfcb)
	ld	h,a
	ld	a,(IPuser)
	ld	l,a
	call	printDU
	ld	de,infcb+1
	call	PFN2
	call	crlf
	ld	c,open
	call	bdosIP
	inc	a
	jr	nz,startit
	call	vprint
	db	'Couldn''t find ZIP file',CR,LF,0
;
; All exits point here for possible future enhancements, such
; as elimination of warm boot.
;
exit:	jp	0		;warm boot
;
crlf:	call	vprint
	db	CR,LF,0
	ret

;
; Judging from https://en.wikipedia.org/wiki/Zip_(file_format)
; this appears to read the file in a technically incorrect way,
; by relying on the local file header only (as a zip-fixing
; program might), and simply skipping past the central directory
; entirely. This leaves us potentially extracting deleted files,
; for example. It's probably not a real problem in most
; cases, but it seemed worth noting.
;
startit:
	ld	a,(mode)	
	or	a
	jr	z,startex
	call	vprint
	db	'Checking...',0
	jr	startcommon


startex:
	call	vprint
	db	'Output drive = ',0
	ld	a,(OPfcb)	
	ld	h,a
	ld	a,(OPuser)
	ld	l,a
	call	printDU		
startcommon:
	call	vprint		
	db	cr,lf
	db	'Name         Length  Stored   Method   Ver  File Date'
	db	' & Time    CRC    STATUS',CR,LF
	db	'============ ======= =======  ======== ===  ========='
	db	'  =====  ======== =======',CR,LF,0
openok:	ld	hl,0
	ld	(zipeof),hl		; clear zipeof and counting
	call	getword
	ld	de,-(('K' shl 8) + 'P')	; Phil Katz's initials!
	add	hl,de
	ld	a,h
	or	l			; hl=0 =>valid signature?
	jr	nz,sigerr
	call	getword
	ld	de,0201h		; check for central directory
	or	a
	sbc	hl,de
	jr	nz,nocfhs
	call	pcfh
	jr	openok
;
nocfhs:	ld	de,0202h		; check for local file header
	or	a
	sbc	hl,de		
	jr	nz,nolfhs
	call	plfh			; process local file header
;	call	crlf
	jr	openok
;
nolfhs:	or	a		; check for end of central dir.
	sbc	hl,de		
	jr	nz,sigerr
	call	vprint
	db	10,13,'Done.',0
	rst	0

sigerr:	call	vprint
	db	'Bad signature in ZIP file',CR,LF,0
	jp	exit
;
; (The belated-CRC type (07,08) is apparently not supported.)
;
; pcfh/pecd are not truly required, they only serve to skip past
; the central directory and end-of-central-directory blocks. But
; they do arguably serve as a small additional check of file
; integrity. It would be faster to simply exit when we spot the
; central directory signature (since the CD/EOCD are by definition
; the last two things) - for large files this might be noticeable.
;
; pcfh - skip past central directory
;
pcfh:	ld	b,12+1
pcfhl1:	push	bc
	call	getword
	pop	bc
	djnz	pcfhl1
	push	hl
	call	getword
	push	hl
	call	getword
	pop	de
	pop	bc
	push	hl		; file comment length
	push	de		; extra field length
	push	bc		; filename length
	ld	b,6		; skip ahead to filename
pcfhl2:	push	bc
	call	getword
	pop	bc
	djnz	pcfhl2
	pop	hl
	call	skpstring	; skip past filename
	pop	hl
	call	skpstring	; skip past extra field
	pop	hl
	call	skpstring	; skip past file comment
	ret
;
; pecd - skip past end-of-central-directory
;
pecd:	ld	b,8		; skip ahead to comment length
pecdl:	push	bc
	call	getword
	pop	bc
	djnz	pecdl
	call	getword		; comment length
	call	skpstring	; skip past comment
	ret
;
; plfh - read local file header, then extract/check file
;
; NB: As mentioned above, this is technically not the correct
; approach to take (but it's almost certainly faster this way
; and will do the right thing for most zips).
;
plfh:	ld	de,lfh			; read local file header
	ld	hl,lfhsiz		
	call	getstring
	ld	hl,opfcb+1		; clear opfcb
	ld	de,opfcb+2
	ld	bc,33
	ld	(hl),b
	ldir
;
; Read filename from LFH into "junk". Note: ZIP file spec
; allows 65535-char filenames!  There is a very small chance that
; a complete filename including directory path could exceed 256
; bytes. The directory path is meaningless to CP/M and needs to
; striped off.  After this there still remains the problem that
; the filename itself may be greater than 8 chars.  Here only 
; the first 8 chars are used and the rest discarded.  There may
; be better solutions.  The 3 chars after a '.' are taken as
; the extension.
;
	ld	de,junk		; put filename here
	ld	hl,(fnl)	; filename length
; read a byte at a time, reseting DE everytime a path seperator
; is encountered until all bytes in the filename have been read.
; '/', '\' and ':' are considered path seperators.  Assumes 
; filename without path does not exceed 255 chars.
rfnlp:
	ld	a,h
	or	l
	jr	z,rdfndon
	push	de
	push	hl
	call	getbyte
	pop	hl
	pop	de
; check for path seperators
	cp	'/'
	jr	z,gotsep
	cp	'\'
	jr	z,gotsep
	cp	':'
	jr	nz,nosep
gotsep:	ld	de,junk		;reset save pointer
	jr	nosav		;don't save seperator
nosep:	ld	(de),a		;save char in junk
	inc	de
nosav:	dec	hl
	jr	rfnlp
rdfndon:
	ld	(de),a		; save null terminator
	ld	hl,(efl)
	call	skpstring	; skip extra field
; put filename without the '.' into the output fcb
	ld	de,junk
	ld	hl,opfn
	ld	b,8
	call	scanfn
	ld	a,(de)
	cp	'.'
	jr	nz,nodot
	inc	de
nodot:	ld	b,3
	call	scanfn
; initialize
	ld	hl,init
	ld	de,vars
	ld	bc,endinit-init
	ldir
	ld	a,(mode)
resmod:	ld	(curmode),a
	xor	a
	ld	(nomtch),a	; clear no match flag 
; check if filename matches destination possibly ambiguous filename
	ld	b,11
	ld	de,fcb2sav		
	ld	hl,opfcb+1		
fchkL:	ld	a,(de)			
	cp	'?'			
	jr	z,fmatch
	cp	(hl)
	jr	nz,noex		; jmp if it doesn't match
fmatch:	
	inc	hl
	inc	de
	djnz	fchkL	
; try opening output
	ld	c,open			
	call	bdosOP
	inc	a
	jr	z,creok
; if checking, process file else skip it
	ld	a,(curmode)
	or	a
	jp	nz,pjunk		
	ld	de,OPfcb+1
	call	PFN1			
	call	vprint
	db	' ',0
	call	opsiz
; the following converts compression method code to a name and outputs it
; for now it is bypassed and x's output instead
;	ld	a,(cm)
;	add	a
;	add	a
;	add	a
;	ld	e,a
;	ld	d,0
;	ld	hl,namtab
;	add	hl,de
;	call	vpstr
	call	vprint
	db	'xxxxxxxx',0
; print version, date and time
	call	opver
	call	vprint
	db	'EXISTS',CR,LF,0	;lwn
noex:
; skip this file
	ld	hl,nomtch	;lwn
	inc	(hl)		;set no match flag - lwn
	ld	a,1		;lwn
	ld	(curmode),a	;set curmode for no extract
	call	ckzlen
; badskp only uses getbyte to skip past a file.  So counting needs 
;   to be NZ to enable decrementing compressed file size and 
;   setting 'zipeof' and returning Ctrl-Z when result becomes zero.
	inc	hl
	inc	(hl)
	call	badskp
	jp	closeo		;lwn
; ckzlen - sets zipeof if length is zero.  Returns HL=zipeof
ckzlen:	ld	hl,(cs)
	ld	de,(cs + 2)
	ld	a,d
	or	e
	or	h
	or	l
	ld	hl,zipeof
	ret	nz
	inc	(hl)		;set zipeof
	ret
;
extrct:	xor	a
	ld	(zipeof),a
	ld	a,(curmode)
	dec	a
	jp	m,doext			
	jr	pjunk
;
; create output file if extracting
creok:	ld	a,(curmode)
	or	a
	jr	nz,pjunk
	ld	c,create		
	call	bdosOP
	inc	a
	jr	nz,pjunk
	call	vprint
	db	'Error creating ',0
	ld	hl,junk
	call	vpstr
	jr	noex

pjunk:
	ld	de,OPfcb+1
	call	PFN1			
doext:	call	vprint
	db	' ',0
	call	ckzlen		;returns hl=zipeof
	inc	hl		;point to 'counting'
	inc	(hl)		;increment 'counting'
	ld	a,(cm)
	or	a
	jr	nz,case1
;
; print uncompressed and compressed file size
	call	opsiz
	call	vprint
	db	' Stored ',0
; print version, date and time
	call	opver
case0w:	ld	a,(zipeof)
	and	1
	jr	nz,closeo
	call	getbyte			
	call	outbyte
	jr	case0w
;
case1:	dec	a
	jr	nz,case2p
	call	unshrink
	jr	closeo
;
case2p:	dec	a
	cp	4
	jr	nc,tryimp
	call	unreduce
	jr	closeo
;
tryimp:	jr	nz,trydfl
	call	unimplode
	jr	closeo
;
trydfl:	cp	6
	jr	nz,badzip
	call	undeflate
	jr	closeo
;
badzip:	call	vprint
	db	'Unknown compression method',0
badskp:	ld	a,(zipeof)
	and	1
	jr	nz,closeo
	call	getbyte
	jr	badskp
	ret
;
closeo:	ld	hl,zipeof
	dec	(hl)
	inc	hl
	dec	(hl)		;decrement 'counting'
	ld	a,(nomtch)
	or	a
	jr	z,close1
;	call	crlf
	ret
close1:	ld	a,(curmode)
	or	a
	jr	nz,nocls
	ld	hl,wrtpt
	ld	a,(hl)
	or	a
	jr	z,noflsh
	ld	de,opbuf
	ld	c,fstdma
	call	bdos
	ld	c,write
	call	bdosOP
noflsh:
	ld	c,close
	call	bdosOP
nocls:	ld	hl,crc32
	ld	de,crc
	scf
	ld	bc,400h
crcclp:	ld	a,(de)
	adc	a,(hl)
	push	af
	or	c
	ld	c,a
	pop	af
	inc	hl
	inc	de
	djnz	crcclp
	ld	a,c
	or	a
	jr	z,crcok
	call	vprint
	db	'CRC ERR'0
	jr	wildck
;
crcok:	call	vprint
	db	'CRC OK',0
; if system supports datestamping - set all datestamps with stamp
; from local file header.
; Test if datestamping available
	ld	a,(DOSTYP)
	or	a
	jr	z,nods		; jmp if no datestamping
; copy date & time to opbuf as create stamp
	ld	hl,dsbuf
	ld	de,(opbuf)
	ld	bc,5
	ldir
; Fill in Datestamp for access and modify
	ld	bc,10		; copy to access & modify stamp
	ld	hl,(opbuf)
;	inc	de
	ldir
;	ld	bc,5		; copy to modify stamp
;	ldir
; set the file's date stamp
	ld	hl,(opbuf)	; date stamp pointer
	ld	de,opfcb	; file fcb
	ld	a,(DOSTYP)
	cp	33h		; test for CP/M Plus
	jr	z,dods3
	cp	'S'		; test for ZSDOS or ZDDOS
	jr	z,dods
	cp	'D'		; test for DateStamper
	jr	nz,nods
dods:	call	pstamp		; set file date/time stamp
	or	a
	jr	z,daterr
	jr	nods
dods3:	ld	bc,followers	; borrow 1k of buffer space
	call	sstpcp
	or	a
	jr	nz,daterr
nods:
; 
wildck:	ld	hl,fcb2sav
	ld	bc,11
	ld	a,'?'
	cpir
	jp	nz,exit
	call	crlf
	ret
;
daterr:
	call	vprint
	db	'Date Stamp Error',CR,LF,0
	jr	wildck
;
getchla:
	call	getcode
	ld	(code),hl
	ld	a,(zipeof)
	and	1
	ret
;
savstk:	ld	hl,(stackp)
	dec	hl
	ld	(stackp),hl
	ld	(hl),a
	ret
;
getcode:
	ld	a,(codesize)
readbits:
	ld	hl,8000h
bitlp:	push	af
	push	hl
getbit:	ld	hl,bleft
	dec	(hl)
	jp	m,readbt
	dec	hl
	rr	(hl)
	pop	hl
	rr	h
	rr	l
	jr	c,bitex
	pop	af
	dec	a
	jr	nz,bitlp
finbit:	srl	h
	rr	l
	jr	nc,finbit
	jr	bitret
bitex:	pop	af
bitret:	ld	a,l
	ret
;
readbt:	push	hl
	call	getbyte
	pop	hl
	ld	(hl),8
	dec	hl
	ld	(hl),a
	jr	getbit
;
scanfn:	ld	a,(de)
	cp	'.'
	jr	z,nocopy
	or	a
	jr	z,nocopy
	inc	de
	dec	b
	jp	m,scanfn
	ld	(hl),a
	inc	hl
	jr	scanfn
;
nocopy:	dec	b
	ret	m
	ld	(hl),' '
	inc	hl
	jr	nocopy
;
getstring:
	ld	a,h
	or	l
	ld	(de),a
	ret	z
	push	de
	push	hl
	call	getbyte
	pop	hl
	pop	de
	ld	(de),a
	inc	de
	dec	hl
	jr	getstring
;
; skpstring - read but do not save a string of bytes from 
;		the input file, ie skip over them
;   Enter:	HL=# of bytes to skip over
skpstring:
	ld	a,h
	or	l
	ret	z
	push	hl
	call	getbyte
	pop	hl
	dec	hl
	jr	skpstring
;
getword:
	call	getbyte
	push	af
	call	getbyte
	pop	hl
	ld	l,h
	ld	h,a
	ret
;
; getbyte - get a byte from input file in A.  If 'counting' NZ then
;		decrement compressed file size and set 'zipeof' if size
;		goes to zero, ie count the bytes read.  If 'counting'
;		is Z, read until 'zipeof' set and then return Ctrl-Z.
;
getbyte:
	ld	a,(counting)
	or	a
	jr	nz,dodci
	ld	a,(zipeof)
	and	1
	ld	a,CtrlZ
	ret	nz
	jr	skpdci
dodci:	ld	hl,(cs)
	ld	de,(cs + 2)
	ld	a,d
	or	e
	or	h
	or	l
	jr	nz,noteof
	ld	hl,zipeof
	inc	(hl)
	ld	a,CtrlZ
	ret
;
noteof:	ld	a,h
	or	l
	dec	hl
	ld	(cs),hl
	jr	nz,skpdci
	dec	de
	ld	(cs + 2),de
skpdci:	ld	hl,readpt
	ld	a,(hl)
	add	a,a
	jr	nc,ptok
	ld	(hl),a
	ld	de,80h
	push	hl
	ld	c,fstdma
	call	bdos
	ld	c,read
	call	bdosIP			
	or	a
	pop	hl
	jr	nz,ateof
ptok:	ld	a,(hl)
	inc	(hl)
	ld	l,a
	ld	h,0
	ld	de,(inbufp)
	add	hl,de
	ld	a,(hl)
	ret
;
ateof:	ld	a,CtrlZ
	ret
;
outb:	ld	hl,(outpos)
	push	hl
	push	af
	ld	a,(omask)
	and	h
	ld	h,a
	pop	af
	ld	de,outbuf
	add	hl,de
	ld	(hl),a
	pop	hl
	inc	hl
	ld	(outpos),hl
	push	af
	ld	a,h
	or	l
	jr	nz,nopos
	ld	hl,(outpos + 2)
	inc	hl
	ld	(outpos + 2),hl
nopos:	pop	af
;
; outbyte - send byte in A to output file.  Count down uncompressed
;		file size and set 'zipeof' if result zero.
;
outbyte:
	push	af
	ld	c,a
; Update CRC if file matches destination AFN
	ld	a,(nomtch)
	or	a
;	ld	a,c
	call	z,updcrc
; decrement uncompressed file size and set zipeof if result zero
	ld	hl,(ucs)
	ld	de,(ucs + 2)
	ld	a,h
	or	l
	dec	hl
	ld	(ucs),hl
	jr	nz,tsthl0
	dec	de
	ld	(ucs + 2),de
tsthl0:	ld	a,h
	or	l
	or	d
	or	e
	jr	nz,noeof
	ld	hl,zipeof
	inc	(hl)
noeof:
; Send byte to output file if extracting
	ld	a,(curmode)	;lwn
	or	a
	jr	nz,popret	
	ld	hl,wrtpt
	ld	a,(hl)
	add	a,a
	jr	nc,wptok
	ld	de,opbuf
	ld	c,fstdma
	call	bdos
	ld	c,write			
	call	bdosOP
	or	a
	jr	z,wptok			
	ld	(mode),a		
	call	vprint
	db	'Write Error',CR,LF,0
popret:	pop	af
	ret

wptok:	jr	nz,nofilb
	ld	hl,opbuf
	ld	de,opbuf + 1
	ld	bc,127
	ld	(hl),CtrlZ
	ldir
	xor	a
	ld	(wrtpt),a
nofilb:	pop	af
	ld	hl,wrtpt
	inc	(hl)
	ld	l,(hl)
	ld	h,0
	ld	de,opbuf - 1
	add	hl,de
	ld	(hl),a
	ret

bdosIP:	
	
	ld	a,(IPuser)
	ld	de,infcb
	jr	bdosIOP

bdosOP:	

	ld	a,(OPuser)
	ld	de,opfcb
bdosIOP:
	push	bc
	push	de
	ld	c,32
	ld	e,a
	call	bdos
	pop	de
	pop	bc
	jp	bdos
;
updcrc:	ld	hl,(crc32)
	ld	de,(crc32 + 2)
;	ld	c,a
	ld	b,8
crclp:	ld	a,l
	xor	c
	srl	c
	srl	d
	rr	e
	rr	h
	rr	l
	rra
	jr	nc,noxor
	ld	a,d
	xor	0edh
	ld	d,a
	ld	a,e
	xor	0b8h
	ld	e,a
	ld	a,h
	xor	83h
	ld	h,a
	ld	a,l
	xor	20h
	ld	l,a
noxor:	djnz	crclp
	ld	(crc32),hl
	ld	(crc32 + 2),de
	ret
;
unshrink:
; print uncompressed and compressed file size
	call	opsiz
	call	vprint
; print method
	db	' Shrunk ',0
; print version, date and time
	call	opver
	ld	a,1fh
	ld	(omask),a
	ld	a,init_bits
	ld	(codesize),a
	ld	hl,+(1 shl init_bits) - 1;
	ld	(maxcode),hl
	ld	hl,first_ent
	ld	(free_ent),hl
	ld	hl,prefix_of
	ld	de,prefix_of + 1
	ld	bc,512
	ld	(hl),c
	ldir
	ld	bc,16386 - 512
	ld	(hl),-1
	ldir
	ld	hl,suffix_of
sol:	ld	(hl),c
	inc	hl
	inc	c
	jr	nz,sol
	call	getchla
	ld	(oldcode),hl
	ret	nz
	ld	a,l
	ld	(finchar),a
	call	outbyte
unshlp:	ld	hl,stack + 8192
	ld	(stackp),hl
	ld	a,(zipeof)
	and	1
	ret	nz
clrlp:	call	z,getchla
	ret	nz
	ld	a,h
	dec	a
	or	l
	jr	nz,noclr
	call	getchla
	ld	a,h
	or	a
	jr	nz,clrlp
	dec	l
	jr	z,bumpcs
	dec	l
	call	z,partial_clear
	jr	clrlp
;
bumpcs:	ld	hl,codesize
	inc	(hl)
	ld	a,(hl)
	cp	max_bits
	ld	hl,maxcmax
	jr	z,atmax
	ld	hl,1
maxclp:	add	hl,hl
	dec	a
	jr	nz,maxclp
	dec	hl
atmax:	ld	(maxcode),hl
	jr	clrlp
;
noclr:	ld	(incode),hl	;;v1.5-1 start unshrink fix
	add	hl,hl
	ld	de,prefix_of
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	ld	hl,(code)
	jr	nz,noKwKw
	ld	a,(finchar)
	call	savstk
	ld	hl,(oldcode)
noKwKw:	ex	de,hl
;
staklp:	ld	hl,100h
	or	a
	sbc	hl,de
	jr	nc,unstak
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	nz,noKw2
	ld	a,(finchar)
	call	savstk
	ld	de,(oldcode)
	jr	staklp
;
noKw2:	ld	hl,suffix_of
	add	hl,de
	ld	a,(hl)
	call	savstk
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	jr	staklp
;
unstak:	ld	hl,suffix_of
	add	hl,de
	ld	a,(hl)
	call	savstk
	ld	(finchar),a	;;v1.5-1 end of unshrink fix
	ld	de,(stackp)
unslp:	ld	hl,stack + 8192
	or	a
	sbc	hl,de
	jr	z,newent
	ld	a,(de)
	inc	de
	push	de
	call	outbyte
	pop	de
	jr	unslp
;
newent:	ld	hl,(free_ent)
	ld	(code),hl
	ex	de,hl
	ld	hl,1fffh
	or	a
	sbc	hl,de
	jr	c,full
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	bc,(oldcode)
	ld	(hl),c
	inc	hl
	ld	(hl),b
	ld	hl,suffix_of
	add	hl,de
	ld	a,(finchar)
	ld	(hl),a
getfre:	inc	de
	ld	hl,1fffh
	or	a
	sbc	hl,de
	jr	c,full1
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	nz,getfre
full1:	ld	(free_ent),de
full:	ld	hl,(incode)
	ld	(oldcode),hl
	jp	unshlp
;
partial_clear:
	ld	de,first_ent
l8:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br8
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	set	7,(hl)
	inc	de
	jr	l8
;
br8:	ld	de,first_ent
l9:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br9
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	res	7,d
	ld	hl,first_ent - 1
	or	a
	sbc	hl,de
	jr	nc,ei10
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	res	7,(hl)
ei10:	pop	de
	inc	de
	jr	l9
;
br9:	ld	de,first_ent
l10:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br10
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	bit	7,(hl)
	jr	z,ei11
	ld	(hl),-1
	dec	hl
	ld	(hl),-1
ei11:	inc	de
	jr	l10
;
br10:	ld	de,first_ent
l11:	ld	hl,maxcmax
	or	a
	sbc	hl,de
	jr	z,br11
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	z,br11
	inc	de
	jr	l11
br11:	ld	(free_ent),de
	ret
;
loadfollowers:
	ld	hl,Slen + 255
	ld	b,0
lflp:	push	bc
	push	hl
	ld	a,6
	call	readbits
	pop	hl
	pop	de
	ld	(hl),a
	push	de
	push	hl
	dec	d
	ld	hl,followers
	call	shftadd
	ld	b,a
	or	a
	jr	z,nofoll
ldfllp:	push	hl
	push	bc
	ld	a,8
	call	readbits
	pop	bc
	pop	hl
	ld	(hl),a
	inc	hl
	djnz	ldfllp
nofoll:	pop	hl
	pop	bc
	dec	hl
	djnz	lflp
	ret
;
unreduce:
	push	af
; print uncompressed and compressed file size
	call	opsiz
; print method
	call	vprint
	db	'Reduced ',0
; print version, date and time
	call	opver
	pop	af
	ld	e,a
	ld	d,0
	ld	hl,_L_table
	add	hl,de
	ld	a,(hl)
	ld	(L_table),a
	ld	hl,_D_shift
	add	hl,de
	ld	a,(hl)
	ld	(D_shift),a
	ld	a,1fh
	ld	(omask),a
	xor	a
	ld	(ExState),a
	ld	(lchar),a
	call	loadfollowers
ur1:	ld	a,(zipeof)
	and	1
	ret	nz
	call	slenlch
	or	a
	jr	nz,ur2
ur4:	ld	a,8
	call	readbits
	jr	ur3
;
ur2:	ld	a,1
	call	readbits
	dec	l
	jr	z,ur4
	call	slenlch
	dec	a
	or	1
	ld	l,a
	xor	a
btlp:	inc	a
	srl	l
	jr	nz,btlp
	call	readbits
	ld	de,followers
	add	hl,de
	ld	de,(lchar - 1)
	call	shftadd
	ld	a,(hl)
ur3:	ld	(nchar),a
	ld	l,a
	ld	a,(ExState)
	or	a
	jr	nz,ur5
	ld	a,l
	cp	DLE
	jr	nz,ur9
	ld	a,1
	ld	(ExState),a
	jr	ur6
;
ur5:	dec	a
	jr	nz,ur7
	ld	a,l
	or	a
	jr	z,ur10
	ld	(V),a
	ld	a,(L_table)
	ld	h,a
	and	l
	cp	h
	ld	l,a
	ld	h,0
	ld	(Len),hl
	jr	nz,ur12
	ld	a,2
	jr	ur11
;
ur10:	ld	(ExState),a
	ld	a,DLE
ur9:	call	outb
	jr	ur6
;
ur7:	dec	a
	jr	nz,ur8
	ld	a,l
	ld	hl,Len
	add	a,(hl)
	ld	(hl),a
	jr	nc,ur12
	inc	hl
	inc	(hl)
ur12:	ld	a,3
	jr	ur11
;
ur8:	dec	a
	jr	nz,ur13
	ld	a,(D_shift)
	ld	b,a
	ld	a,(V)
ur14:	srl	a
	djnz	ur14
	ld	h,a
	inc	hl
	ld	bc,(Len)
	inc	bc
	inc	bc
	inc	bc
	call	callback
ur13:	xor	a
ur11:	ld	(ExState),a
ur6:	ld	a,(nchar)
	ld	(lchar),a
	jp	ur1
;
slenlch:
	ld	hl,(lchar)
	ld	h,0
	ld	de,Slen
	add	hl,de
	ld	a,(hl)
	ret
;
shftadd:
	ld	e,0
	srl	d
	rr	e
	srl	d
	rr	e
	add	hl,de
	ret
;
callback:
	push	bc
	push	hl
	ld	hl,(outpos)
	ld	de,(outpos + 2)
	pop	bc
	or	a
	sbc	hl,bc
	jr	nc,cb2
	dec	de
cb2:	pop	bc
cb3:	bit	7,d
	jr	z,cb4
	ld	a,b
	or	c
	jr	z,cb4
	xor	a
	call	outbp
	inc	hl
	ld	a,h
	or	l
	jr	nz,cb5
	inc	de
cb5:	dec	bc
	jr	cb3
;
cb4:	ex	de,hl
cb6:	ld	a,b
	or	c
	ret	z
	ld	a,(omask)
	and	d
	ld	d,a
	ld	hl,outbuf
	add	hl,de
	ld	a,(hl)
	call	outbp
	inc	de
	dec	bc
	jr	cb6
;
outbp:	push	hl
	push	de
	push	bc
	call	outb
	pop	bc
	pop	de
	pop	hl
	ret
;
readlengths:
	ld	a,8
	call	readbits
	ld	d,h
	ld	e,d
	inc	hl
	ld	b,h
	ld	c,l
	ld	(ix + _maxlength),e
	ld	(ix + _maxlength + 1),d
	push	ix
	pop	hl
	inc	hl
	inc	hl
	inc	hl
rl1:	ld	a,b
	or	c
	ret	z
	push	bc
	push	de
	push	hl
	ld	a,4
	call	readbits
	inc	a
	push	af
	ld	a,4
	call	readbits
	inc	a
	ld	b,a
	pop	af
	ld	c,a
	pop	hl
	pop	de
	ld	a,(ix + _maxlength)
	cp	c
	jr	nc,rl2
	ld	(ix + _maxlength),c
rl2:	inc	hl
	inc	hl
	inc	hl
	ld	(hl),e
	inc	hl
	ld	(hl),c
	inc	e
	djnz	rl2
	pop	bc
	dec	bc
	jr	rl1
;
sortlengths:
	ld	h,(ix + _entries + 1)
	ld	l,(ix + _entries)
	ld	b,h
	ld	c,l
	ld	(entrs),hl
sl7:	srl	b
	rr	c
sl1:	ld	a,b
	or	c
	ret	z
	ld	(noswps),a
	push	ix
	ld	de,4
	add	ix,de
	push	ix
	pop	iy
	add	iy,bc
	add	iy,bc
	add	iy,bc
	add	iy,bc
	ld	hl,(entrs)
	or	a
	sbc	hl,bc
sl2:	ld	a,(ix + _bitlength)
	cp	(iy + _bitlength)
	jr	c,sl4
	jr	nz,sl3
	ld	a,(iy + _value)
	cp	(ix + _value)
	jr	nc,sl4
sl3:	ld	d,e
sl5:	ld	a,(ix)
	push	af
	ld	a,(iy)
	ld	(ix),a
	pop	af
	ld	(iy),a
	inc	ix
	inc	iy
	dec	d
	jr	nz,sl5
	ld	a,d
	ld	(noswps),a
	jr	sl6
;
sl4:	add	ix,de
	add	iy,de
sl6:	dec	hl
	ld	a,h
	or	l
	jr	nz,sl2
	pop	ix
	ld	a,(noswps)
	or	a
	jr	nz,sl7
	jr	sl1
;
generatetrees:
	ld	l,(ix + _entries)
	ld	h,(ix + _entries + 1)
	ld	c,l
	ld	b,h
	push	ix
	pop	de
	add	hl,hl
	add	hl,hl
	add	hl,de
	push	hl
	pop	iy
	xor	a
	ld	d,a
	ld	e,a
	ld	h,a
	ld	l,a
	ld	(lbl),a
gt1:	ld	a,b
	or	c
	ret	z
	dec	bc
	add	hl,de
	ld	a,(lbl)
	cp	(iy + _bitlength)
	jr	z,gt2
	ld	a,(iy + _bitlength)
	ld	(lbl),a
	sub	16
	ex	de,hl
	ld	hl,1
	jr	z,gt3
gt4:	add	hl,hl
	inc	a
	jr	nz,gt4
gt3:	ex	de,hl
gt2:	ld	(iy + _code),l
	ld	(iy + _code + 1),h
	push	de
	ld	de,-4
	add	iy,de
	pop	de
	jr	gt1
;
ldtrees:
	ld	a,(gpbf)
	rra
	ld	l,a
	and	1
	add	a,6
	ld	(dictb),a
	ld	a,l
	rra
	and	1
	ld	(ltp),a
	set	1,a
	ld	(mml),a
	ld	ix,lit_tree
	ld	hl,256
	call	nz,ld_tree
	ld	hl,64
	ld	ix,len_tree
	call	ld_tree
	ld	hl,64
	ld	ix,dist_tre
ld_tree:
	ld	(ix + _entries),l
	ld	(ix + _entries + 1),h
	call	readlengths
	call	sortlengths
	call	generatetrees
reversebits:
	push	ix
	pop	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
rb1:	inc	hl
	inc	hl
	inc	hl
	ld	c,(hl)
	ld	b,8
rb2:	srl	c
	adc	a,a
	djnz	rb2
	push	af
	inc	hl
	ld	c,(hl)
	ld	b,8
rb3:	srl	c
	adc	a,a
	djnz	rb3
	dec	hl
	ld	(hl),a
	pop	af
	inc	hl
	ld	(hl),a
	dec	de
	ld	a,d
	or	e
	jr	nz,rb1
	ret
;
readtree:
	push	ix
	pop	iy
	ld	de,4
	add	iy,de
	ld	b,d
	ld	e,d
	ld	h,d
	ld	l,d
rt1:	push	hl
	push	de
	push	bc
	ld	a,1
	call	readbits
	pop	af
	push	af
	or	a
	jr	z,rt2
rt3:	add	hl,hl
	dec	a
	jr	nz,rt3
rt2:	pop	bc
	pop	de
	add	hl,de
	ex	de,hl
	inc	b
	pop	hl
rt4:	ld	a,(iy + _bitlength)
	cp	b
	jr	nc,rt5
	push	de
	ld	de,4
	add	iy,de
	pop	de
	inc	hl
	ld	a,(ix + _entries)
	sub	l
	jr	nz,rt4
	ld	a,(ix + _entries + 1)
	sub	h
	jr	nz,rt4
rt6:	dec	a
	ret
;
rt5:	ld	a,(iy + _bitlength)
	cp	b
	jr	nz,rt1
	ld	a,(iy + _code)
	cp	e
	jr	nz,rt7
	ld	a,(iy + _code + 1)
	cp	d
	jr	nz,rt7
	ld	a,(iy + _value)
	ret
;
rt7:	push	de
	ld	de,4
	add	iy,de
	pop	de
	inc	hl
	ld	a,(ix + _entries)
	sub	l
	jr	nz,rt5
	ld	a,(ix + _entries + 1)
	sub	h
	jr	nz,rt5
	jr	rt6
;
unimplode:
; print uncompressed and compressed file size
	call	opsiz
; print method
	call	vprint
	db	'Imploded',0
; print version, date and time
	call	opver
	ld	a,1fh
	ld	(omask),a
	call	ldtrees
ui1:	ld	a,(zipeof)
	and	1
	ret	nz
	inc	a
	call	readbits
	or	a
	jr	z,ui2
	ld	a,(ltp)
	or	a
	jr	z,ui3
	ld	ix,lit_tree
	call	readtree
	jr	ui4
;
ui3:	ld	a,8
	call	readbits
ui4:	call	outb
	jr	ui1
;
ui2:	ld	a,(dictb)
	call	readbits
	push	hl
	ld	ix,dist_tre
	call	readtree
	ld	l,a		;;v1.5-1 unimplode fix
	ld	h,0		;;v1.5-1
	ld	bc,(dictb - 1)
ui5:	add	hl,hl
	djnz	ui5
	pop	bc
	add	hl,bc
	push	hl
	ld	ix,len_tree
	call	readtree
	ld	l,a
	ld	h,0
	cp	63
	jr	nz,ui6
	push	hl
	ld	a,8
	call	readbits
	pop	de
	add	hl,de
ui6:	ld	de,(mml)
	ld	d,0
	add	hl,de
	ld	b,h
	ld	c,l
	pop	hl
	inc	hl
	call	callback
	jr	ui1
;
nextsymbol:
	ld	(treep),hl
nsloop:	push	hl
	ld	a,1
	call	readbits
	pop	hl
	or	a
	jr	z,nsleft
	inc	hl
	inc	hl
nsleft:	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	ld	a,d
	cp	10h
	jr	nc,nsleaf
	or	e
	ret	z

	ld	hl,(treep)
	add	hl,de
	add	hl,de
	add	hl,de
	add	hl,de
	jr	nsloop

nsleaf:	and	0fh
	ld	d,a
	ret
;
buildcode:
	ld	(lenp),hl
	ld	(nodes),de
	ld	(nrsym),bc

	ld	hl,blcnt
	ld	de,blcnt + 1
	ld	bc,2 * maxcl + 1
	ld	(hl),b
	ldir

	ld	bc,(nrsym)
	ld	de,(lenp)
bclp1:	ld	a,(de)
	add	a,a
	jr	z,bcnol
	ld	hl,blcnt
	add	a,l
	ld	l,a
	jr	nc,bcnc1
	inc	h
bcnc1:	ld	a,(hl)
	inc	a
	ld	(hl),a
	jr	nz,bcnol
	inc	hl
	inc	(hl)
bcnol:	inc	de
	dec	bc
	ld	a,b
	or	c
	jr	nz,bclp1

	ld	hl,0
	push	hl

	ld	bc,1
bclp2:	ld	a,c
	sub	maxcl + 1
	jr	nc,bccn2

	ld	hl,blcnt
	add	hl,bc
	add	hl,bc
	dec	hl
	ld	d,(hl)
	dec	hl
	ld	e,(hl)

	pop	hl
	add	hl,de
	add	hl,hl
	push	hl

	ex	de,hl
	ld	hl,ncode
	add	hl,bc
	add	hl,bc
	ld	(hl),e
	inc	hl
	ld	(hl),d

	inc	c
	jr	bclp2
bccn2:	pop	hl

	ld	hl,(nrsym)
	add	hl,hl
	add	hl,hl
	ld	b,h
	ld	c,l
	ld	hl,(nodes)
	ld	d,h
	ld	e,l
	inc	de
	dec	bc
	ld	(hl),0
	ldir

	ld	hl,1
	ld	(nnode),hl

	ld	bc,0
bclp3:	ld	hl,(lenp)
	add	hl,bc
	ld	a,(hl)
	or	a
	jr	z,bccn3

	push	bc

	push	af
	ld	hl,ncode
	add	a,a
	add	a,l
	ld	l,a
	jr	nc,bc4
	inc	h
bc4:	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	(bcode),de
	inc	de
	ld	(hl),d
	dec	hl
	ld	(hl),e
	pop	af

	ld	hl,1
bclp4:	dec	a
	or	a
	jr	z,bccn4
	add	hl,hl
	jr	bclp4
bccn4:	ld	(bmask),hl

	ld	hl,(nodes)
bclp5:	ld	de,(bcode)
	ld	bc,(bmask)
	ld	a,d
	and	b
	ld	d,a
	ld	a,e
	and	c
	ld	e,a
	or	d
	jr	z,bcleft
	inc	hl
	inc	hl
bcleft:	srl	b
	rr	c
	ld	(bmask),bc
	ld	a,b
	or	c
	jr	z,bccn5

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	a,d
	or	e
	jr	nz,bc6
	ld	de,(nnode)
	ld	(hl),d
	dec	hl
	ld	(hl),e
	inc	de
	ld	(nnode),de
	dec	de

bc6:	ld	hl,(nodes)
	add	hl,de
	add	hl,de
	add	hl,de
	add	hl,de
	jr	bclp5

bccn5:	pop	bc

	ld	(hl),c
	inc	hl
	ld	a,b
	or	10h
	ld	(hl),a

bccn3:	inc	bc
	ld	hl,(nrsym)
	or	a
	sbc	hl,bc
	jr	nz,bclp3
	ret
;
huffman:
	ld	a,5
	call	readbits
	inc	a
	ld	l,a
	ld	h,1
	ld	(hlit),hl

	ld	a,5
	call	readbits
	inc	a
	ld	(hdist),a

	ld	a,4
	call	readbits
	add	a,4
	ld	c,a

	ld	b,0
	ld	de,clord
hmlp1:	ld	a,b
	cp	c
	jr	nc,hmcn1
	push	bc
	push	de
	ld	a,3
	call	readbits
	pop	hl
	ld	c,(hl)
	ld	b,0
	ex	de,hl
	ld	hl,lenld
	add	hl,bc
	ld	(hl),a
	pop	bc
	inc	de
	inc	b
	jr	hmlp1

hmcn1:	xor	a
	ld	c,a
hmlp2:	ld	a,b
	cp	nrcl
	jr	nc,hmcn2
	ld	a,(de)
	ld	hl,lenld
	add	a,l
	ld	l,a
	jr	nc,hmnc2
	inc	h
hmnc2:	ld	(hl),c
	inc	de
	inc	b
	jr	hmlp2

hmcn2:	ld	hl,lenld
	ld	de,cltr
	ld	bc,nrcl
	call	buildcode

	ld	hl,(hlit)
	ld	a,(hdist)
	add	a,l
	ld	c,a
	ld	a,h
	adc	a,0
	ld	b,a
	ld	hl,lenld
hmlp3:	push	bc
	push	hl
	ld	hl,cltr
	call	nextsymbol
	ld	a,e

	cp	010h
	jr	nz,hmn16
	ld	a,2
	call	readbits
	pop	hl
	pop	bc
	add	a,3
	ld	d,a
	dec	hl
	ld	e,(hl)
	inc	hl
hmlp4:	ld	(hl),e
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp4
	jr	hmcn3

hmn16:	cp	011h
	jr	nz,hmn17
	ld	a,3
	call	readbits
	pop	hl
	pop	bc
	add	a,3
	ld	d,a
	xor	a
hmlp5:	ld	(hl),a
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp5
	jr	hmcn3

hmn17:	cp	012h
	jr	nz,hmn18
	ld	a,7
	call	readbits
	pop	hl
	pop	bc
	add	a,11
	ld	d,a
	xor	a
hmlp6:	ld	(hl),a
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp6
	jr	hmcn3

hmn18:	pop	hl
	pop	bc
	ld	(hl),a
	inc	hl
	dec	bc

hmcn3:	ld	a,b
	or	c
	jr	nz,hmlp3

	ld	hl,lenld
	ld	de,littr
	ld	bc,(hlit)
	call	buildcode

	ld	hl,(hlit)
	ld	de,lenld
	add	hl,de
	ld	de,disttr
	ld	a,(hdist)
	ld	c,a
	ld	b,0
	call	buildcode

	ld	hl,(inbps)
	ld	a,l
	or	h
	jr	z,hmnext
	ld	(inbufp),hl
	ld	a,(rdpts)
	ld	(readpt),a
	ld	a,(blfts)
	ld	(bleft),a
	ld	a,(bitbs)
	ld	(bitbuf),a
	ld	hl,counting
	inc	(hl)

hmnext:	ld	hl,littr
	call	nextsymbol
	ld	a,d
	dec	a
	or	e
	ret	z
	ld	a,(zipeof)
	and	1
	ret	nz

	ld	a,d
	or	a
	jr	nz,hmsym
	ld	a,e
	call	outb
	jr	hmnext

hmsym:	dec	e
	ld	d,0
	ld	hl,lenex
	add	hl,de
	ld	a,(hl)
	ld	hl,0
	or	a
	jr	z,hmnlen
	push	de
	call	readbits
	pop	de
hmnlen:	push	hl
	ld	hl,lenbas
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	add	hl,de
	push	hl

	ld	hl,disttr
	call	nextsymbol
	ld	hl,dstex
	add	hl,de
	ld	a,(hl)
	ld	hl,0
	or	a
	jr	z,hmndst
	push	de
	call	readbits
	pop	de
hmndst:	push	hl
	ld	hl,dstbas
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	add	hl,de

	pop	bc
	call	callback
	jr	hmnext
;
undeflate:
; print uncompressed and compressed file size
	call	opsiz
; print method
	call	vprint
	db	'Deflated',0
; print version, date and time
	call	opver
	ld	a,7fh
	ld	(omask),a

udloop:	ld	a,(zipeof)
	and	1
	ret	nz

	ld	a,1
	call	readbits
	push	af

	ld	a,2
	call	readbits
	or	a
	jr	nz,udnt0

	xor	a
	ld	(bleft),a
	ld	a,16
	call	readbits
	push	hl
	ld	a,16
	call	readbits
	pop	bc
	scf
	adc	hl,bc
	jr	nz,udblm

udt0lp:	ld	a,b
	or	c
	jr	z,udnext
	ld	a,(zipeof)
	and	1
	jr	nz,udpret
	push	bc
	call	getbyte
	call	outb
	pop	bc
	dec	bc
	jr	udt0lp

udnt0:	dec	a
	jr	nz,udnt1
	ld	hl,(inbufp)
	ld	(inbps),hl
	ld	a,(readpt)
	ld	(rdpts),a
	ld	a,(bleft)
	ld	(blfts),a
	ld	a,(bitbuf)
	ld	(bitbs),a
	ld	hl,counting
	dec	(hl)
	ld	hl,static_pre
	ld	(inbufp),hl
	xor	a
	ld	(readpt),a
	ld	(bleft),a
	call	huffman
	jr	udnext

udnt1:	dec	a
	jr	nz,udubt
	ld	hl,0
	ld	(inbps),hl
	call	huffman

udnext:	pop	af
	or	a
	jr	z,udloop
	ret

udpret:	pop	af
	ret
udbskp:	ld	a,(zipeof)
	and	1
	jr	nz,udpret
	call	getbyte
	jr	udbskp
udblm:	call	vprint
	db	'Block length mismatch',CR,LF,0
	jr	udbskp
udubt:	call	vprint
	db	'Unknown block type',CR,LF,0
	jr	udbskp
; Print drive and user # - H has drive and L has user #
printDU:	
	ld	a,h		;drive 0 => default drive
	dec	a
	jp	p,notDEF	
; default drive
	ld	c,25		;get default drive
	push	hl		;just to be safe
	call	bdos
	pop	hl		
notDEF:
	add	'A'		;convert to ASCII
	call	cout		;perserves registers
	ld	a,(zflag)
	or	a
	ld	a,l		;get user code
	jr	nz,notDFU
	bit	7,a		;default user?
	jr	nz,notDFU
	ld	e,0ffh
	ld	c,32
	call	bdos		;retuens default user # in A	
notDFU:	and	1fh
	call	PAFDC		;output A as decimal digits 	
	ld	a,':'
	jp	cout
;
; opsiz - output uncompressed and compressed file size as 7 
;		blank filled digits
opsiz:
; First print uncompressed size
	ld	hl,ucs
	ld	a,7
	call	plwdc
	call	vprint
	db	' ',0
;
; now output compressed file size as 7 blank filled digits
	ld	hl,cs
	ld	a,7
	call	plwdc
	call	vprint
	db	'  ',0
	ret
;
; opver - output zip version
;
opver:
	ld	hl,lfh
	ld	a,4
	call	plwdc
	call	vprint
	db	'  ',0
;	ret
;
; opdat - output date and time
;
opdat:
; First convert date from MSDOS to universal format
	ld	hl,(lmfd)	; HL<-modify date
	ld	de,dsbuf	; put date stamp here
	call	dcvt		; date now in create buffer
; Then convert time from MSDOS to universal format
	ld	hl,(lmft)	; get modify time
	call	tcvt		; time now in create stamp
; print date as day then month 
	ld	a,0ffh		; choose day then month
	ld	hl,dsbuf
	call	pdats2		; print date
	call	vprint
	db	'  ',0
; print time in military format
	ld	a,0ffh		; choose military format
	ld	hl,dsbuf	; point to BCD date sting
	call	ptims1		; print time
	call	vprint
	db	' ',0
; print 32 bit CRC as 8 hex digits (assume CRC stored little endian)
	ld	hl,(crc+2)	; most significant 16 bits
	call	PHL4HC		; print as 4 hex digits
	ld	hl,(crc)	; least significant 16 bits
	call	PHL4HC
	call	vprint
	db	'  ',0
	ret
;
; dcvt - convert MS-DOS date to DateStamper format
;   Enter:  	HL = MS-DOS formatted date word
;		DE = Pointer to storage buffer in DE. 
;
; MS-DOS 16-bit date format:
; Bits [15:9] = year - 1980
; Bits	[8:5] = month of year
; Bits	[4:0] = day of month
;
dcvt:
; shift HL right one bit so HL has year and month in high order
; bits of L
	ld	c,l		; save L
	srl	h		; Shift H right, LSB to carry
	rr	l		; Shift L right, carry to MSB
	ld	a,h
	sub	20		; try 2000 and greater
	jr	nc,y2k
	add	80+20		; 80 to 99
y2k:	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
; shift month to bits [3:0] of L
	SRL	L		; Shift L right, carry ignored
	SRL	L		; Shift L right, carry ignored
	SRL	L		; Shift L right, carry ignored
	SRL	L		; month now in L 
	ld	a,l
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ld	a,c		; get day
	and	1Fh
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ret
;
; tcvt - Convert time from MS-DOS to DateStamper format and save in 
; storage buffer.  Seconds not converted.
;   Enter:  	HL = MS-DOS formatted time word
;		DE = Pointer to storage buffer in DE. 
;
; MS-DOS 16-bit packed binary time format
;    Bits	[15:11] = hours
;    Bits	[10:5]  = minutes
;    Bits	[4:0]   = seconds/2
;
tcvt:	ld	b,3		; Loop counter for shifting
tcvtlp:	srl	h		; Shift H right, LSB to carry
	rr	l		; Shift L right, carry to MSB
	djnz	tcvtlp		; Repeat 3 times. when done, hours in H
	SRL	L		; Shift L right, carry ignored
	srl	l		; Now have minutes in L
	ld	A,H		; Get hours in A
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ld	a,l		; Now do minutes
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
;	inc	de		; Advance pointer
	ret
;
; Convert BIN to BCD
; Enter: A = Binary number to be converted
; Exit : A = Two BCD digits
;		 All registers preserved
;
BINBCD: OR	A
	RET	Z		; Zero is same
	PUSH	BC		; Save register
	LD	B,A		; Set counter
	XOR	A
BCDLP:	INC	A		; Count up BCD..
	DAA
	DJNZ	BCDLP		; ..til all gone
	POP	BC
	RET
; data storage . . .
;
zipeof:	db	2
counting:
	db	0
init:
	db	0	; for bleft
	db	0	; for wrtpt
	dw	0,0	; for outpos
	dw	-1,-1	; for crc32
endinit:
dsbuf:	db	0,0,0,0,0
inbufp:	dw	0080h
readpt:	db	80h		;was 0
omask:	db	1fh
_L_table:
	db	7fh, 3fh, 1fh, 0fh
_D_shift:
	db	07h, 06h, 05h, 04h
clord:	db	16, 17, 18
	db	0, 8
	db	7, 9
	db	6, 10
	db	5, 11
	db	4, 12
	db	3, 13
	db	2, 14
	db	1, 15
lenbas:	dw	3, 4
	dw	5, 6
	dw	7, 8
	dw	9, 10
	dw	11, 13
	dw	15, 17
	dw	19, 23
	dw	27, 31
	dw	35, 43
	dw	51, 59
	dw	67, 83
	dw	99, 115
	dw	131, 163
	dw	195, 227
	dw	258
lenex:	db	0, 0
	db	0, 0
	db	0, 0
	db	0, 0
	db	1, 1
	db	1, 1
	db	2, 2
	db	2, 2
	db	3, 3
	db	3, 3
	db	4, 4
	db	4, 4
	db	5, 5
	db	5, 5
	db	0
dstbas:	dw	1, 2
	dw	3, 4
	dw	5, 7
	dw	9, 13
	dw	17, 25
	dw	33, 49
	dw	65, 97
	dw	129, 193
	dw	257, 385
	dw	513, 769
	dw	1025, 1537
	dw	2049, 3073
	dw	4097, 6145
	dw	8193, 12289
	dw	16385, 24577
dstex:	db	0, 0
	db	0, 0
	db	1, 1
	db	2, 2
	db	3, 3
	db	4, 4
	db	5, 5
	db	6, 6
	db	7, 7
	db	8, 8
	db	9, 9
	db	10, 10
	db	11, 11
	db	12, 12
	db	13, 13
static_pre:
	db	0ffh, 05bh, 000h, 06ch, 003h, 036h, 0dbh, 0b6h
	db	06dh, 0dbh, 0b6h, 06dh, 0dbh, 0b6h, 0cdh, 0dbh
	db	0b6h, 06dh, 0dbh, 0b6h, 06dh, 0dbh, 0a8h, 06dh
	db	0ceh, 08bh, 06dh, 03bh


	end	;start
