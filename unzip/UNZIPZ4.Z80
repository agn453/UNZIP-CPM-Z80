; UNZIPZ.Z80
;
;		Z-System UNZIPPER
;	Dissolves all MS-DOS Zip files
;
	.z80
Vers	equ	04
Revisn	equ	1		;;v0.4-1
;
;
; Version 0.4-1 -- December 7, 2020 -- Lars
;	Incorporated more Russell Marks speed improvments
;	which further optimized the bit-readers.  These included
;	self-modifying code with an unrolled end loop 
;	in rdbybits, and adding a "rd1bit" macro, for about a 
;	12% speed improvement on overall extraction time.
;	All speedups have resulted in a 45% improvement in 
;	speed comapred to V0.3-4

;
; Version 0.4-0 -- December 6, 2020 -- Lars
;	Added speed improvements to the unDeflate algorithm
;	developed by Russell Marks.  First, a table-based CRC 
;	was implemented yielding a 20% speed improvement but 
;	increased code size by about 1kbyte mainly to hold the 
;	CRC table.  Calls to readbits when eight or fewer bit 
;	values are passed is optimised by a new rdbybits 
;	routine (yields	another 13% speed improvement).  
;	readbits itself also rewritten for improved speed.
;	Overall speed improvement of about 33% compared to
;	V0.3-4.  Fixed a bug in output of PKZIP verion # when
;	processing ZIPs created by 32 bit programs.  Cleaned
;	up ouput format.
;
; Version 0.3-4 -- December 1, 2020 -- Lars
;	Added print out of information in the local file header
;	thus completing one of Simon Cran's uncompleted tasks.
;	Streamlined logic for processing files.
;
; Version 0.3-3 -- November 22, 2020 -- Lars
;	Added date stamping.  Date in local file header applied to
;	extacted file.
;
; Version 0.3-2 -- September 3, 2020 -- Lars
;	Major & minor Improvments plus bug fixes.
;	Fixed long filename problem due to directory paths in the filename
;	Added a local stack pointer.
;	Added Martin's UnDeflate algorithm (based on the work by
;	Keir Fraser's HiTech-C code at
;	https://github.com/keirf/Amiga-Stuff/blob/master/inflate/degzip_portable.c
;
; Version 0.3-1 -- June 17, 2020 -- Lars
;
;	Fixed bugs in the unshrink and unimplode algorithms
;	developed by Martin who was inspired by postings to 
;	the USENET newgroup comp.os.cpm.  Flaws in both
;	the un-implode and un-shrink routines were found to 
;	be causing CRC errors or program crashes.
;
;	For un-implode, the algorithm is essentially a translation
;	of the PKZ101 MS-DOS algorithm in C that has been hand optimized
;	into Z80 assembly language.  However, the readtree() function
;	was incorrectly returning a byte value in the A register, when
;	the shift routine at label ui5 was expecting a 16-bit value in HL.
;
;	For unshrink, there is a race condition with handling the "KwKwK"
;	case that was omitted from the routine.
;
;	Both updates are flagged with ;;v0.3-1 comments, and the
;	version sign-on message now includes the revision.
;
; Version 0.2-0 UNZIPZ -- 4/25/91 -- Simon Cran
;
;The files in this archive are my Z-modified version of UNZIP 1.2.  
;by David P. Goodenough.  They consist of three files in order to 
;make sure that the unitialised data ends up at the end of all files 
;linked.  Also, because the unitialised data file (UDATZI.Z80) 
;needed to share some equates with the main program, all equates 
;have been put in a separate .LIB file.
;
	.request	udatzi	
	extrn	IPuser,OPuser
	extrn	mode,junk,lfh,gpbf,cm,lmft
	extrn	lmfd,crc,cs,ucs,fnl,efl
	extrn	endlfh,lfhsiz,opfcb,opfn,opext,bitbuf,vars
	extrn	bleft,wrtpt,outpos,crc32,curmode,opbuf
	extrn	L_table,D_shift,V,nchar,lchar,ExState
	extrn	Len,ltp,mml,dictb,noswps,entrs
;	extrn	lbl,oldcode,offset,codesize,maxcode,free_ent
	extrn	lbl,treep,lenp,nodes,nrsym,nnode,bcode,bmask
	extrn	lenld,cltr,littr,disttr,bitbs,blfts
	extrn	oldcode,offset,codesize,maxcode,free_ent
	extrn	blcnt,ncode,hlit,hdist,inbps,rdpts
	extrn	finchar,stackp,incode,code,outbuf,suffix_of
	extrn	prefix_of,Slen,lit_tree,len_tree,dist_tre,followers,stack
	extrn	fcb2sav,eodata,locstk,nomtch
;					
	.request	zslib
	extrn	sstpcp,pdats2,ptims1,plwdc,phl2dc,GUA,SUA,phl2dc
;
	.request	z3lib
;
	.request	syslib
	extrn	INITFC,SETDMA,PHL4HC,pafdc,PFN1,PFN2,cout
;
	.request	vlib	
	extrn	Z3VINIT
;	extrn	Z3VINI
	extrn	vpstr,vprint
	cseg
;
	.request	dslib
	extrn	timini,pstamp,DOSTYP,TIMTYP
	extrn	@BDOS,CAPS
	global	ENVPTR

	include		UNZIPEQU.LIB	;M80 needs caps
;	maclib		unzipequ
;
	
	jp	start
	db	'Z3ENV'
	db	3
ENVPTR:	dw	0
	dw	100h
zflag:	db	0FFh

usage:	db	'Syntax:  ',1,'UNZIP [du:]ufn[.ZIP][ du:][afn ][/o]',CR,LF
	db	'If no option specified, UNZIP checks the CRC of the files.',CR,LF
	db	'Options: E - extract files.',CR,LF,0

start:	ld	sp,locstk
	ld	hl,(bdos+1)
	ld	de,-128
	add	hl,de
	ld	de,eodata
	ccf
	sbc	hl,de
	jr	nc,nufram
	call	vprint
	db	'Not enough memory -- aborting',CR,LF,0
	rst	0
nufram:	call	timini		; check for datestamping support
	; Global variables returned:
	; DOSTYP ='S'=>ZSDOS, 'D'=>Datestamper & '3'=>CP/M Plus.
	;    0=>no datestamping
	; DOSVER has version number, 22=>CP/M 2.2 and
	; compatiblle. 
	ld	hl,eodata
	call	PHL4HC
	call	crlf
	ld	de,ENVPTR
	ld	a,d
	or	e
	jr	nz,strt
	xor	a		; not running zsystem
	ld	(zflag),a
strt:
	call	z3vinit		
	call	vprint
	db	'UNZIPZ  Version '
	db	Vers/10+'0','.',Vers mod 10+'0'
	db	'-',Revisn mod 10+'0'
	db	' - SC',CR,LF,LF,0
	ld	hl,(5dh)
	or	a
	ld	de,('/' SHL 8)+'/'
	sbc	hl,de
	jr	nz,notHELP
help:	ld	hl,usage
	call	vpstr
	jp	exit
		
notHELP:
	ld	a,(infcb+1)	
	cp	' '
	jr	z,HELP		
	ld	a,(infcb+13)	
	ld	(IPuser),a	
	ld	a,(fcb2+13)	
	ld	(OPuser),a	
	ld	hl,fcb2
	ld	a,(hl)		
	ld	(opfcb),a	
	inc	hl
	ld	bc,11
	ld	de,fcb2sav
	ldir
	ld	a,(fcb2+1)	
	cp	'/'		
	jr	z,nofspec	
	cp	' '
	jr	nz,notall
nofspec:
; set default to match all, ie fill out fcb filename with '?'	
	ld	bc,10
	ld	hl,fcb2sav
	ld	de,fcb2sav+1	
	ld	(hl),'?'
	ldir			
notall:	ld	a,(80h)		
	ld	b,a
	ld	hl,81h
	ld	a,'/'
optLOOP:
	inc	hl
	cp	(hl)
	jr	z,OPTIONfnd
	djnz	optLOOP
	jr	noOPT

OPTIONfnd:
	inc	hl
	ld	a,(hl)
	sub	EXTRACT
	jr	z,setOPT
	djnz	OPTIONfnd
noOPT:	or	1
setOPT:	ld	(mode),a		;mode=0 => extract file
	ld	a,(065h)
	cp	' '
	jr	nz,wasext
	ld	hl,('I' SHL 8) + 'Z'
	ld	(065h),hl
	ld	a,'P'
	ld	(067h),a
wasext:
	call	vprint
	db	'ZIP archive  = ',0
	ld	a,(INfcb)
	ld	h,a
	ld	a,(IPuser)
	ld	l,a
	call	printDU
	ld	de,infcb+1
	call	PFN2
	call	crlf
	ld	c,open
	call	bdosIP
	inc	a
	jr	nz,startit
	call	vprint
	db	'Couldn''t find ZIP file',CR,LF,0
;
; All exits point here for possible future enhancements, such
; as elimination of warm boot.
;
exit:	jp	0		;warm boot
;
crlf:	call	vprint
	db	CR,LF,0
	ret

;
; Judging from https://en.wikipedia.org/wiki/Zip_(file_format)
; this appears to read the file in a technically incorrect way,
; by relying on the local file header only (as a zip-fixing
; program might), and simply skipping past the central directory
; entirely. This leaves us potentially extracting deleted files,
; for example. It's probably not a real problem in most
; cases, but it seemed worth noting.
;
startit:
	ld	a,(mode)	
	or	a
	jr	z,startex
	call	vprint
	db	'Checking...',0
	jr	startcommon


startex:
	call	vprint
	db	'Output drive = ',0
	ld	a,(OPfcb)	
	ld	h,a
	ld	a,(OPuser)
	ld	l,a
	call	printDU		
startcommon:
	call	vprint		
	db	cr,lf
	db	'Name         Length  Stored   Method   Ver  File Date'
	db	' & Time    CRC    STATUS',CR,LF
	db	'============ ======= =======  ======== ===  ========='
	db	'  =====  ======== =======',CR,LF,0
openok:	ld	hl,0
	ld	(zipeof),hl		; clear zipeof and counting
; should be pointing at beginning of either a Local file
; header or a Central Directory Structure
; 1st and 2nd bytes should be 'KP' (Phil Katz's initials little endian)
; 3rd and 4th bytes should be either 0403h or 0201h
; where 403h => local header and 201 => Central Directory
; Structure which is at the end of the input file. 
; 605h=>end central dir.  Note only interested in local 
; header which preceeds each compressed file.
	call	getword
	ld	de,-(('K' shl 8) + 'P')	; Phil Katz's initials!
	add	hl,de
	ld	a,h
	or	l			; hl=0 =>valid signature?
	jr	nz,sigerr
	call	getword
	ld	de,0201h		; check for central directory
	or	a
	sbc	hl,de
	jr	nz,nocfhs
	call	pcfh
	jr	openok
;
nocfhs:	ld	de,0202h		; check for local file header
	or	a
	sbc	hl,de		
	jr	nz,nolfhs
	call	plfh			; process local file header
	jr	openok
;
nolfhs:	or	a		; check for end of central dir.
	sbc	hl,de		
	jr	nz,sigerr
	call	vprint
	db	'Done.   ',0
	rst	0

sigerr:	call	vprint
	db	'Bad signature in ZIP file',CR,LF,0
	jp	exit
;
; (The belated-CRC type (07,08) is apparently not supported.)
;
; pcfh/pecd are not truly required, they only serve to skip past
; the central directory and end-of-central-directory blocks. But
; they do arguably serve as a small additional check of file
; integrity. It would be faster to simply exit when we spot the
; central directory signature (since the CD/EOCD are by definition
; the last two things) - for large files this might be noticeable.
;
; pcfh - skip past central directory
;
pcfh:	ld	b,12+1
pcfhl1:	push	bc
	call	getword
	pop	bc
	djnz	pcfhl1
	push	hl
	call	getword
	push	hl
	call	getword
	pop	de
	pop	bc
	push	hl		; file comment length
	push	de		; extra field length
	push	bc		; filename length
	ld	b,6		; skip ahead to filename
pcfhl2:	push	bc
	call	getword
	pop	bc
	djnz	pcfhl2
	pop	hl
	call	skpstring	; skip past filename
	pop	hl
	call	skpstring	; skip past extra field
	pop	hl
	call	skpstring	; skip past file comment
	ret
;
; pecd - skip past end-of-central-directory
;
pecd:	ld	b,8		; skip ahead to comment length
pecdl:	push	bc
	call	getword
	pop	bc
	djnz	pecdl
	call	getword		; comment length
	call	skpstring	; skip past comment
	ret
;
; plfh - read local file header, then extract/check file
;
; NB: As mentioned above, this is technically not the correct
; approach to take (but it's almost certainly faster this way
; and will do the right thing for most zips).
;
plfh:	ld	de,lfh			; read local file header
	ld	hl,lfhsiz		
	call	getstring
	ld	hl,opfcb+1		; clear opfcb
	ld	de,opfcb+2
	ld	bc,33
	ld	(hl),b
	ldir
;
; Read filename from LFH into "junk". Note: ZIP file spec
; allows 65535 char filenames!  There is a very small chance that
; a complete filename including directory path could exceed 256
; bytes. The directory path is meaningless to CP/M and needs to
; striped off.  After this there still remains the problem that
; the filename itself may be greater than 8 chars.  Here only 
; the first 8 chars are used and the rest discarded.  There may
; be better solutions.  The 3 chars after a '.' are taken as
; the extension.
;
	ld	de,junk		; put filename here
	ld	hl,(fnl)	; filename length
; read a byte at a time, reseting DE everytime a path seperator
; is encountered until all bytes in the filename have been read.
; '/', '\' and ':' are considered path seperators.  Assumes 
; filename without path does not exceed 255 chars.
rfnlp:
	ld	a,h
	or	l
	jr	z,rdfndon
	push	de
	push	hl
	call	getbyte
	pop	hl
	pop	de
; check for path seperators
	cp	'/'
	jr	z,gotsep
	cp	'\'
	jr	z,gotsep
	cp	':'
	jr	nz,nosep
gotsep:	ld	de,junk		;reset save pointer
	jr	nosav		;don't save seperator
nosep:	ld	(de),a		;save char in junk
	inc	de
nosav:	dec	hl
	jr	rfnlp
rdfndon:
	ld	(de),a		; save null terminator
	ld	hl,(efl)
	call	skpstring	; skip extra field
; put filename without the '.' into the output fcb
	ld	de,junk
	ld	hl,opfn
	ld	b,8
	call	scanfn
	ld	a,(de)
	cp	'.'
	jr	nz,nodot
	inc	de
nodot:	ld	b,3
	call	scanfn
; Process the file, either extract files matching template if 
; destination drive given or check CRC for every file file that
; matches destination template.  Do not extract if it already 
; exists on host.  This mimics the way UNARC works.
; Initialize
	ld	hl,init
	ld	de,vars
	ld	bc,endinit-init
	ldir
	ld	a,(mode)
resmod:	ld	(curmode),a
	xor	a
	ld	(nomtch),a	; clear no match flag 
; check if filename matches possibly ambiguous destination filename
	ld	b,11
	ld	hl,opfcb+1		
	ld	de,fcb2sav		
fchkL:
;   See if the name matches the destination
	ld	a,(de)			
	cp	'?'			
	jr	z,fmatch
	cp	(hl)
	jr	z,fmatch
	call	vprint 		; it doesn't match so skip it
	db	'Skipping',CR,0
	jp	skipit
fmatch:	
	inc	hl
	inc	de
	djnz	fchkL	
; Filename matches - try opening to see if it exists
	ld	a,(curmode)	; don't check existence if checking
	or	a
	jp	nz,pjunk		
	ld	c,open			
	call	bdosOP
	inc	a
	jr	z,creok
; file already exists, so tell user then skip it
	ld	de,OPfcb+1
	call	PFN1			
	call	vprint
	db	' ',0
; print uncompressed and compressed file size
	call	opsiz
; the following converts compression method code to a name and outputs it
; for now it is bypassed and x's output instead
;	ld	a,(cm)
;	add	a
;	add	a
;	add	a
;	ld	e,a
;	ld	d,0
;	ld	hl,namtab
;	add	hl,de
;	call	vpstr
	call	vprint
	db	'xxxxxxxx',0
; print version, date and time
	call	opver
	call	vprint
	db	'EXISTS',CR,LF,0	;lwn
	jp	skipit
;noex: ; -- moved to badskp --
; skip this file
;	ld	hl,nomtch	;lwn
;	inc	(hl)		;set no match flag - lwn
;	ld	a,1		;lwn
;	ld	(curmode),a	;set curmode for no extract
;	call	ckzlen
; badskp only uses getbyte to skip past a file.  So counting needs 
;   to be NZ to enable decrementing compressed file size and 
;   setting 'zipeof' and returning Ctrl-Z when result becomes zero.
;	inc	hl
;	inc	(hl)
;	call	badskp
;	jp	closeo		;lwn
; ckzlen - sets zipeof if length is zero.  Returns HL=zipeof
ckzlen:	ld	hl,(cs)
	ld	de,(cs + 2)
	ld	a,d
	or	e
	or	h
	or	l
	ld	hl,zipeof
	ret	nz
	inc	(hl)		;set zipeof
	ret
;
extrct:	xor	a
	ld	(zipeof),a
	ld	a,(curmode)
	dec	a
	jp	m,doext			
	jr	pjunk
;
; create output file if extracting
creok:	ld	a,(curmode)
	or	a
	jr	nz,pjunk
	ld	c,create		
	call	bdosOP
	inc	a
	jr	nz,pjunk
	call	vprint
	db	'Error creating ',0
	ld	hl,junk
	call	vpstr
	jp	exit			; quit if create file fails
;	jr	noex

pjunk:
	ld	de,OPfcb+1
	call	PFN1			
; print uncompressed and compressed file size
	call	opsiz
doext:	call	vprint
	db	' ',0
	call	ckzlen		;returns hl=zipeof
	inc	hl		;point to 'counting'
	inc	(hl)		;increment 'counting'
	ld	a,(cm)
	or	a
	jr	nz,case1
; file is stored
	call	vprint
	db	' Stored ',0
; print version, date and time
	call	opver
case0w:	ld	a,(zipeof)
	and	1
	jp	nz,closeo
	call	getbyte
	call	outbyte
	jr	case0w
; is this file shrunk?
case1:	dec	a
	jr	nz,case2p
	call	unshrink
	jr	closeo
; is this file reduced?
case2p:	dec	a
	cp	4
	jr	nc,tryimp
	call	unreduce
	jr	closeo
; is this file imploded?
tryimp:	jr	nz,trydfl
	call	unimplode
	jr	closeo
; is file deflated
trydfl:	cp	6
	jr	nz,badzip
	call	undeflate
	jr	closeo
; Bad or unknown compression method
badzip:	call	vprint
	db	'Unknown compression method -- Skipping',CR,LF,0
skipit:	ld	a,1
	ld	(curmode),a	; set to no extract
;	inc	a
	ld	(counting),a	; make sure getbyte counts bytes
badskp:	ld	a,(zipeof)	; get eof flag
	and	1		; eof?
	jr	nz,skpdun
	call	getbyte
	jr	badskp
skpdun:	ld	hl,zipeof	; point to eof flag
	dec	(hl)		; clear it
	inc	hl		; point to counting
	dec	(hl)		; decrement it
	ret
;
closeo:	call	skpdun
	ld	a,(curmode)	; check mode for this file
	or	a
	jr	nz,nocls
close1:	ld	a,(curmode)
	or	a
	jr	nz,nocls
	ld	hl,wrtpt
	ld	a,(hl)
	or	a
	jr	z,noflsh
	ld	de,opbuf
	ld	c,fstdma
	call	bdos
	ld	c,write
	call	bdosOP
noflsh:
	ld	c,close
	call	bdosOP
nocls:	ld	hl,crc32
	ld	de,crc
	scf
	ld	bc,400h
crcclp:	ld	a,(de)
	adc	a,(hl)
	push	af
	or	c
	ld	c,a
	pop	af
	inc	hl
	inc	de
	djnz	crcclp
	ld	a,c
	or	a
	jr	z,crcok
	call	vprint
	db	'CRC ERR',0
	jr	wildck
;
crcok:	call	vprint
	db	'CRC OK',0
; if system supports datestamping - set all datestamps of extracted
; files with stamp from local file header.
; Test if datestamping available
	ld	a,(curmode)
	or	a
	jr	nz,nods
	ld	a,(DOSTYP)
	or	a
	jr	z,nods		; jmp if no datestamping
; copy date & time to opbuf as create stamp
	ld	hl,dsbuf
	ld	de,(opbuf)
	ld	bc,5
	ldir
; Fill in Datestamp for access and modify
	ld	bc,10		; copy to access & modify stamps
	ld	hl,(opbuf)
	ldir
; set the file's date stamp
	ld	hl,(opbuf)	; date stamp pointer
	ld	de,opfcb	; file fcb
	ld	a,(DOSTYP)
	cp	33h		; test for CP/M Plus
	jr	z,dods3
	cp	'S'		; test for ZSDOS or ZDDOS
	jr	z,dods
	cp	'D'		; test for DateStamper
	jr	nz,nods
dods:	call	pstamp		; set file date/time stamp
	or	a
	jr	z,daterr
	jr	nods
dods3:	ld	bc,followers	; borrow 1k of buffer space
	call	sstpcp
	or	a
	jr	nz,daterr
nods:
; 
wildck:	ld	hl,fcb2sav
	ld	bc,11
	ld	a,'?'
	cpir
	jp	nz,exit
	call	crlf
	ret
;
daterr:
	call	vprint
	db	'Date Stamp Error',CR,LF,0
	jr	wildck
;
getchla:
	call	getcode
	ld	(code),hl
	ld	a,(zipeof)	; get eof flag
	and	1		; eof?
	ret
;
savstk:	ld	hl,(stackp)
	dec	hl
	ld	(stackp),hl
	ld	(hl),a
	ret
;
getcode:
	ld	a,(codesize)
readbits:
	ld	b,a
	ld	c,80h		; bits rotate into C and A
	xor	a		; (rra is 4 cycles vs 8 for others)
	ld	hl,(bitbuf)	; keep bitbuf in L, bleft in H
getbit:	dec	h
	jp	p,getbt2	; skip if new byte not needed yet
	push	af
	push	bc
	call	getbyte
	ld	l,a		; new bitbuf
	ld	h,7		; 8 bits left, pre-dec'd
	pop	bc
	pop	af
getbt2:	rr	l
	rr	c
	rra
	jr	c,bitret
	djnz	getbit
finbit: srl	c
	rra
	jp	nc,finbit	; jp likely faster in this case
bitret:	ld	(bitbuf),hl	; update bitbuf/bleft
	ld	h,c		; return bits in HL and A
	ld	l,a
	ret
;
; rdbybits - faster version of readbits for <=8 bits.
; Due to the implementation this must not ever be called with A>8.
; (No caller seems to require saving BC, so I removed that for both
; this and readbits.)
;
rdbybits:
	ld	(rdbyop+1),a	; modify jr instruction at rdbyop
	ld	b,a
	xor	a		; bits rotate into A (rra faster)
	ld	hl,(bitbuf)	; keep bitbuf in L, bleft in H
rdbylp:	dec	h
	jp	p,rdby1		; skip if new byte not needed yet
	ld	c,a
	push	bc
	call	getbyte
	ld	l,a		; new bitbuf
	ld	h,7		; 8 bits left, pre-dec'd
	pop	bc
	ld	a,c
rdby1:	rr	l
	rra
	djnz	rdbylp
	ld	(bitbuf),hl	; update bitbuf/bleft
	or	a
rdbyop:	jr	rdbyr8
rdbyr8:	rra			; 8x rra, not all are used in practice but
	rra			; this arrangement simplifies code above
	rra
	rra
	rra
	rra
	rra
	rra
	ld	h,b		; B still zero after the final djnz
	ld	l,a		; return bits in HL and A
	ret
;
; rd1bit - faster version which reads a single bit only.
; The jp instruction here needs the uses of a local symbol
; The "local" statement must be right after "macro"
;
rd1bit	macro
	local	??0001
	ld	hl,(bitbuf)	;; keep bitbuf in L, bleft in H
	dec	h
	jp	p,??0001	;; jump to "xor a", past jp op plus 6 bytes:
	call	getbyte		;; (3 bytes)
	ld	l,a		;; (1 byte)  new bitbuf
	ld	h,7		;; (2 bytes) 8 bits left, pre-dec'd
??0001:	xor	a		;; jp op above jumps here
	rr	l
	ld	(bitbuf),hl	;; update bitbuf/bleft
	ld	h,a		;; A still zero
	rla			;; return bit in HL and A
	ld	l,a
	endm
;
; copy filename string of max length (BE) starting at (DE) to memory
; starting at (HL) stop copying if a null or period is encountered
; and pad remainder with spaces.
scanfn:	ld	a,(de)
	cp	'.'
	jr	z,nocopy
	or	a
	jr	z,nocopy
	inc	de
	dec	b
	jp	m,scanfn
	and	7fh		; remove high bit
	ld	(hl),a
	inc	hl
	jr	scanfn
;
nocopy:	dec	b
	ret	m
	ld	(hl),' '
	inc	hl
	jr	nocopy
;
; getstring - Read a string of bytes from input file
;   Enter:	DE=location to start storing string
;		HL=# of bytes get
;   Exit:	DE pointing just past the last byte stored
;
getstring:
	ld	a,h
	or	l
	ld	(de),a
	ret	z
	push	de
	push	hl
	call	getbyte
	pop	hl
	pop	de
	ld	(de),a
	inc	de
	dec	hl
	jr	getstring
;
; skpstring - read but do not save a string of bytes from 
;		the input file, ie skip over them
;   Enter:	HL=# of bytes to skip over
skpstring:
	ld	a,h
	or	l
	ret	z
	push	hl
	call	getbyte
	pop	hl
	dec	hl
	jr	skpstring
;
getword:
	call	getbyte
	push	af
	call	getbyte
	pop	hl
	ld	l,h
	ld	h,a
	ret
;
; getbyte - get a byte from input file in A.  If 'counting' NZ then
;	decrement compressed file size and set 'zipeof' if size
;	goes to zero, ie count the bytes read.  If 'counting'
;	is Z, read until 'zipeof', set it and then return Ctrl-Z.
;
getbyte:
	ld	a,(counting)
	or	a
	jr	nz,dodci
	ld	a,(zipeof)	; get eof flag
	and	1		; test if eof
	ld	a,CtrlZ
	ret	nz		; at eof so return CtrlZ
	jr	skpdci
dodci:
	ld	hl,(cs)		; get compressed file size
	ld	de,(cs + 2)
	ld	a,d
	or	e		; test if file length zero
	or	h
	or	l
	jr	nz,noteof	; jmp if length not 0
	ld	hl,zipeof
	inc	(hl)		; set eof
	ld	a,CtrlZ		; and return a CtrlZ
	ret
;
noteof:	ld	a,h		; decrement 32 bit compressed file size
	or	l
	dec	hl
	ld	(cs),hl		; low order word
	jr	nz,skpdci	; do we need to borrow
	dec	de
	ld	(cs + 2),de	; save high order word
skpdci:	ld	hl,readpt
	ld	a,(hl)
	add	a,a
	jr	nc,ptok
	ld	(hl),a
	ld	de,80h
	push	hl
	ld	c,fstdma
	call	bdos
	ld	c,read
	call	bdosIP			
	or	a
	pop	hl
	jr	nz,ateof
ptok:	ld	a,(hl)
	inc	(hl)
	ld	l,a
	ld	h,0
	ld	de,(inbufp)
	add	hl,de
	ld	a,(hl)
	ret
;
ateof:	ld	a,CtrlZ
	ret
;
outb:	ld	hl,(outpos)
	push	hl
	push	af
	ld	a,(omask)
	and	h
	ld	h,a
	pop	af
	ld	de,outbuf
	add	hl,de
	ld	(hl),a
	pop	hl
	inc	hl
	ld	(outpos),hl
	push	af
	ld	a,h
	or	l
	jr	nz,nopos
	ld	hl,(outpos + 2)
	inc	hl
	ld	(outpos + 2),hl
nopos:	pop	af
;
; outbyte - send byte in A to output file.  Count down uncompressed
;		file size and set 'zipeof' if result zero.
;
outbyte:
	push	af
	ld	c,a
; Update CRC if file matches destination AFN
	ld	a,(nomtch)
	or	a
	call	z,updcrc
; decrement uncompressed file size and set zipeof if result zero
	ld	hl,(ucs)
	ld	de,(ucs + 2)
	ld	a,h
	or	l
	dec	hl
	ld	(ucs),hl
	jr	nz,tsthl0
	dec	de
	ld	(ucs + 2),de
tsthl0:	ld	a,h		; test if zero
	or	l
	or	d
	or	e
	jr	nz,noeof
	ld	hl,zipeof	; set eof flag
	inc	(hl)
noeof:
; Send byte to output file only if extracting
	ld	a,(curmode)
	or	a
	jr	nz,popret	
	ld	hl,wrtpt
	ld	a,(hl)
	add	a,a
	jr	nc,wptok
	ld	de,opbuf
	ld	c,fstdma
	call	bdos
	ld	c,write			
	call	bdosOP
	or	a
	jr	z,wptok			
	ld	(mode),a		
	call	vprint
	db	'Write Error',CR,LF,0
popret:	pop	af
	ret
;
wptok:	jr	nz,nofilb
	ld	hl,opbuf	;fill buffer with CtrlZ
	ld	de,opbuf + 1
	ld	bc,127
	ld	(hl),CtrlZ
	ldir
	xor	a		;clear write buffer offset
	ld	(wrtpt),a
nofilb:	pop	af
	ld	hl,wrtpt	;bump write buffer offset
	inc	(hl)
	ld	l,(hl)		;calc opbuf addr	
	ld	h,0
	ld	de,opbuf - 1
	add	hl,de
	ld	(hl),a		;save byte in buffer
	ret

bdosIP:	
	
	ld	a,(IPuser)
	ld	de,infcb
	jr	bdosIOP

bdosOP:	

	ld	a,(OPuser)
	ld	de,opfcb
bdosIOP:
	push	bc
	push	de
	ld	c,32
	ld	e,a
	call	bdos
	pop	de
	pop	bc
	jp	bdos
;
; Update CRC with byte in C
;
; based on this from crc32() in degzip_portable.c:
;    for (i = 0; i < len; i++)
;        crc = crc32_tab[(uint8_t)(crc ^ *b++)] ^ (crc >> 8);
;
updcrc:	ld	a,c
	ld	bc,(crc32)
	xor	c		; A=low byte of crc xor output byte
	ld	h,0
	ld	l,a
	add	hl,hl		; *2
	add	hl,hl		; *4
	ld	de,crc32tab
	add	hl,de
	ld	de,(crc32 + 2)
	; now DEBC is "crc", and HL points to low byte of
	; relevant crc32tab entry. Do the xor with "crc"/256,
	; starting from the low bytes.
	ld	a,(hl)
	xor	b
	ld	c,a
	inc	hl
	ld	a,(hl)
	xor	e
	ld	b,a
	inc	hl
	ld	a,(hl)
	xor	d
	ld	e,a
	inc	hl
	ld	d,(hl)		; high byte is a simple copy
	ld	(crc32 + 2),de
	ld	(crc32),bc
	ret
;
unshrink:
; print method
	call	vprint
	db	' Shrunk ',0
; print version, date and time
	call	opver
	ld	a,1fh
	ld	(omask),a
	ld	a,init_bits
	ld	(codesize),a
	ld	hl,+(1 shl init_bits) - 1;
	ld	(maxcode),hl
	ld	hl,first_ent
	ld	(free_ent),hl
	ld	hl,prefix_of
	ld	de,prefix_of + 1
	ld	bc,512
	ld	(hl),c
	ldir
	ld	bc,16386 - 512
	ld	(hl),-1
	ldir
	ld	hl,suffix_of
sol:	ld	(hl),c
	inc	hl
	inc	c
	jr	nz,sol
	call	getchla
	ld	(oldcode),hl
	ret	nz
	ld	a,l
	ld	(finchar),a
	call	outbyte
unshlp:	ld	hl,stack + 8192
	ld	(stackp),hl
	ld	a,(zipeof)	; test if eof reached
	and	1
	ret	nz		; return if not
clrlp:	call	z,getchla
	ret	nz
	ld	a,h
	dec	a
	or	l
	jr	nz,noclr
	call	getchla
	ld	a,h
	or	a
	jr	nz,clrlp
	dec	l
	jr	z,bumpcs
	dec	l
	call	z,partial_clear
	jr	clrlp
;
bumpcs:	ld	hl,codesize
	inc	(hl)
	ld	a,(hl)
	cp	max_bits
	ld	hl,maxcmax
	jr	z,atmax
	ld	hl,1
maxclp:	add	hl,hl
	dec	a
	jr	nz,maxclp
	dec	hl
atmax:	ld	(maxcode),hl
	jr	clrlp
;
noclr:	ld	(incode),hl	;;v1.5-1 start unshrink fix
	add	hl,hl
	ld	de,prefix_of
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	ld	hl,(code)
	jr	nz,noKwKw
	ld	a,(finchar)
	call	savstk
	ld	hl,(oldcode)
noKwKw:	ex	de,hl
;
staklp:	ld	hl,100h
	or	a
	sbc	hl,de
	jr	nc,unstak
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	nz,noKw2
	ld	a,(finchar)
	call	savstk
	ld	de,(oldcode)
	jr	staklp
;
noKw2:	ld	hl,suffix_of
	add	hl,de
	ld	a,(hl)
	call	savstk
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	jr	staklp
;
unstak:	ld	hl,suffix_of
	add	hl,de
	ld	a,(hl)
	call	savstk
	ld	(finchar),a	;;v1.5-1 end of unshrink fix
	ld	de,(stackp)
unslp:	ld	hl,stack + 8192
	or	a
	sbc	hl,de
	jr	z,newent
	ld	a,(de)
	inc	de
	push	de
	call	outbyte
	pop	de
	jr	unslp
;
newent:	ld	hl,(free_ent)
	ld	(code),hl
	ex	de,hl
	ld	hl,1fffh
	or	a
	sbc	hl,de
	jr	c,full
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	bc,(oldcode)
	ld	(hl),c
	inc	hl
	ld	(hl),b
	ld	hl,suffix_of
	add	hl,de
	ld	a,(finchar)
	ld	(hl),a
getfre:	inc	de
	ld	hl,1fffh
	or	a
	sbc	hl,de
	jr	c,full1
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	nz,getfre
full1:	ld	(free_ent),de
full:	ld	hl,(incode)
	ld	(oldcode),hl
	jp	unshlp
;
partial_clear:
	ld	de,first_ent
l8:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br8
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	set	7,(hl)
	inc	de
	jr	l8
;
br8:	ld	de,first_ent
l9:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br9
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	push	de
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	res	7,d
	ld	hl,first_ent - 1
	or	a
	sbc	hl,de
	jr	nc,ei10
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	res	7,(hl)
ei10:	pop	de
	inc	de
	jr	l9
;
br9:	ld	de,first_ent
l10:	ld	hl,(free_ent)
	or	a
	sbc	hl,de
	jr	z,br10
	ld	hl,prefix_of + 1
	add	hl,de
	add	hl,de
	bit	7,(hl)
	jr	z,ei11
	ld	(hl),-1
	dec	hl
	ld	(hl),-1
ei11:	inc	de
	jr	l10
;
br10:	ld	de,first_ent
l11:	ld	hl,maxcmax
	or	a
	sbc	hl,de
	jr	z,br11
	ld	hl,prefix_of
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	and	(hl)
	inc	a
	jr	z,br11
	inc	de
	jr	l11
br11:	ld	(free_ent),de
	ret
;
loadfollowers:
	ld	hl,Slen + 255
	ld	b,0
lflp:	push	bc
	push	hl
	ld	a,6
	call	rdbybits
	pop	hl
	pop	de
	ld	(hl),a
	push	de
	push	hl
	dec	d
	ld	hl,followers
	call	shftadd
	ld	b,a
	or	a
	jr	z,nofoll
ldfllp:	push	hl
	push	bc
	ld	a,8
	call	rdbybits
	pop	bc
	pop	hl
	ld	(hl),a
	inc	hl
	djnz	ldfllp
nofoll:	pop	hl
	pop	bc
	dec	hl
	djnz	lflp
	ret
;
unreduce:
	push	af
; print method
	call	vprint
	db	'Reduced ',0
; print version, date and time
	call	opver
	pop	af
	ld	e,a
	ld	d,0
	ld	hl,_L_table
	add	hl,de
	ld	a,(hl)
	ld	(L_table),a
	ld	hl,_D_shift
	add	hl,de
	ld	a,(hl)
	ld	(D_shift),a
	ld	a,1fh
	ld	(omask),a
	xor	a
	ld	(ExState),a
	ld	(lchar),a
	call	loadfollowers
ur1:	ld	a,(zipeof)	; test if eof reached
	and	1
	ret	nz
	call	slenlch
	or	a
	jr	nz,ur2
ur4:	ld	a,8
	call	rdbybits
	jr	ur3
;
ur2:	rd1bit
	dec	l
	jr	z,ur4
	call	slenlch
	dec	a
	or	1
	ld	l,a
	xor	a
btlp:	inc	a
	srl	l
	jr	nz,btlp
	call	readbits
	ld	de,followers
	add	hl,de
	ld	de,(lchar - 1)
	call	shftadd
	ld	a,(hl)
ur3:	ld	(nchar),a
	ld	l,a
	ld	a,(ExState)
	or	a
	jr	nz,ur5
	ld	a,l
	cp	DLE
	jr	nz,ur9
	ld	a,1
	ld	(ExState),a
	jr	ur6
;
ur5:	dec	a
	jr	nz,ur7
	ld	a,l
	or	a
	jr	z,ur10
	ld	(V),a
	ld	a,(L_table)
	ld	h,a
	and	l
	cp	h
	ld	l,a
	ld	h,0
	ld	(Len),hl
	jr	nz,ur12
	ld	a,2
	jr	ur11
;
ur10:	ld	(ExState),a
	ld	a,DLE
ur9:	call	outb
	jr	ur6
;
ur7:	dec	a
	jr	nz,ur8
	ld	a,l
	ld	hl,Len
	add	a,(hl)
	ld	(hl),a
	jr	nc,ur12
	inc	hl
	inc	(hl)
ur12:	ld	a,3
	jr	ur11
;
ur8:	dec	a
	jr	nz,ur13
	ld	a,(D_shift)
	ld	b,a
	ld	a,(V)
ur14:	srl	a
	djnz	ur14
	ld	h,a
	inc	hl
	ld	bc,(Len)
	inc	bc
	inc	bc
	inc	bc
	call	callback
ur13:	xor	a
ur11:	ld	(ExState),a
ur6:	ld	a,(nchar)
	ld	(lchar),a
	jp	ur1
;
slenlch:
	ld	hl,(lchar)
	ld	h,0
	ld	de,Slen
	add	hl,de
	ld	a,(hl)
	ret
;
shftadd:
	ld	e,0
	srl	d
	rr	e
	srl	d
	rr	e
	add	hl,de
	ret
;
callback:
	push	bc
	push	hl
	ld	hl,(outpos)
	ld	de,(outpos + 2)
	pop	bc
	or	a
	sbc	hl,bc
	jr	nc,cb2
	dec	de
cb2:	pop	bc
cb3:	bit	7,d
	jr	z,cb4
	ld	a,b
	or	c
	jr	z,cb4
	xor	a
	call	outbp
	inc	hl
	ld	a,h
	or	l
	jr	nz,cb5
	inc	de
cb5:	dec	bc
	jr	cb3
;
cb4:	ex	de,hl
cb6:	ld	a,b
	or	c
	ret	z
	ld	a,(omask)
	and	d
	ld	d,a
	ld	hl,outbuf
	add	hl,de
	ld	a,(hl)
	call	outbp
	inc	de
	dec	bc
	jr	cb6
;
outbp:	push	hl
	push	de
	push	bc
	call	outb
	pop	bc
	pop	de
	pop	hl
	ret
;
readlengths:
	ld	a,8
	call	rdbybits
	ld	d,h
	ld	e,d
	inc	hl
	ld	b,h
	ld	c,l
	ld	(ix + _maxlength),e
	ld	(ix + _maxlength + 1),d
	push	ix
	pop	hl
	inc	hl
	inc	hl
	inc	hl
rl1:	ld	a,b
	or	c
	ret	z
	push	bc
	push	de
	push	hl
	ld	a,4
	call	rdbybits
	inc	a
	push	af
	ld	a,4
	call	rdbybits
	inc	a
	ld	b,a
	pop	af
	ld	c,a
	pop	hl
	pop	de
	ld	a,(ix + _maxlength)
	cp	c
	jr	nc,rl2
	ld	(ix + _maxlength),c
rl2:	inc	hl
	inc	hl
	inc	hl
	ld	(hl),e
	inc	hl
	ld	(hl),c
	inc	e
	djnz	rl2
	pop	bc
	dec	bc
	jr	rl1
;
sortlengths:
	ld	h,(ix + _entries + 1)
	ld	l,(ix + _entries)
	ld	b,h
	ld	c,l
	ld	(entrs),hl
sl7:	srl	b
	rr	c
sl1:	ld	a,b
	or	c
	ret	z
	ld	(noswps),a
	push	ix
	ld	de,4
	add	ix,de
	push	ix
	pop	iy
	add	iy,bc
	add	iy,bc
	add	iy,bc
	add	iy,bc
	ld	hl,(entrs)
	or	a
	sbc	hl,bc
sl2:	ld	a,(ix + _bitlength)
	cp	(iy + _bitlength)
	jr	c,sl4
	jr	nz,sl3
	ld	a,(iy + _value)
	cp	(ix + _value)
	jr	nc,sl4
sl3:	ld	d,e
sl5:	ld	a,(ix)
	push	af
	ld	a,(iy)
	ld	(ix),a
	pop	af
	ld	(iy),a
	inc	ix
	inc	iy
	dec	d
	jr	nz,sl5
	ld	a,d
	ld	(noswps),a
	jr	sl6
;
sl4:	add	ix,de
	add	iy,de
sl6:	dec	hl
	ld	a,h
	or	l
	jr	nz,sl2
	pop	ix
	ld	a,(noswps)
	or	a
	jr	nz,sl7
	jr	sl1
;
generatetrees:
	ld	l,(ix + _entries)
	ld	h,(ix + _entries + 1)
	ld	c,l
	ld	b,h
	push	ix
	pop	de
	add	hl,hl
	add	hl,hl
	add	hl,de
	push	hl
	pop	iy
	xor	a
	ld	d,a
	ld	e,a
	ld	h,a
	ld	l,a
	ld	(lbl),a
gt1:	ld	a,b
	or	c
	ret	z
	dec	bc
	add	hl,de
	ld	a,(lbl)
	cp	(iy + _bitlength)
	jr	z,gt2
	ld	a,(iy + _bitlength)
	ld	(lbl),a
	sub	16
	ex	de,hl
	ld	hl,1
	jr	z,gt3
gt4:	add	hl,hl
	inc	a
	jr	nz,gt4
gt3:	ex	de,hl
gt2:	ld	(iy + _code),l
	ld	(iy + _code + 1),h
	push	de
	ld	de,-4
	add	iy,de
	pop	de
	jr	gt1
;
ldtrees:
	ld	a,(gpbf)
	rra
	ld	l,a
	and	1
	add	a,6
	ld	(dictb),a
	ld	a,l
	rra
	and	1
	ld	(ltp),a
	set	1,a
	ld	(mml),a
	ld	ix,lit_tree
	ld	hl,256
	call	nz,ld_tree
	ld	hl,64
	ld	ix,len_tree
	call	ld_tree
	ld	hl,64
	ld	ix,dist_tre
ld_tree:
	ld	(ix + _entries),l
	ld	(ix + _entries + 1),h
	call	readlengths
	call	sortlengths
	call	generatetrees
reversebits:
	push	ix
	pop	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
rb1:	inc	hl
	inc	hl
	inc	hl
	ld	c,(hl)
	ld	b,8
rb2:	srl	c
	adc	a,a
	djnz	rb2
	push	af
	inc	hl
	ld	c,(hl)
	ld	b,8
rb3:	srl	c
	adc	a,a
	djnz	rb3
	dec	hl
	ld	(hl),a
	pop	af
	inc	hl
	ld	(hl),a
	dec	de
	ld	a,d
	or	e
	jr	nz,rb1
	ret
;
readtree:
	push	ix
	pop	iy
	ld	de,4
	add	iy,de
	ld	b,d
	ld	e,d
	ld	h,d
	ld	l,d
rt1:	push	hl
	push	de
	push	bc
	rd1bit
	pop	af
	push	af
	or	a
	jr	z,rt2
rt3:	add	hl,hl
	dec	a
	jr	nz,rt3
rt2:	pop	bc
	pop	de
	add	hl,de
	ex	de,hl
	inc	b
	pop	hl
rt4:	ld	a,(iy + _bitlength)
	cp	b
	jr	nc,rt5
	push	de
	ld	de,4
	add	iy,de
	pop	de
	inc	hl
	ld	a,(ix + _entries)
	sub	l
	jr	nz,rt4
	ld	a,(ix + _entries + 1)
	sub	h
	jr	nz,rt4
rt6:	dec	a
	ret
;
rt5:	ld	a,(iy + _bitlength)
	cp	b
	jr	nz,rt1
	ld	a,(iy + _code)
	cp	e
	jr	nz,rt7
	ld	a,(iy + _code + 1)
	cp	d
	jr	nz,rt7
	ld	a,(iy + _value)
	ret
;
rt7:	push	de
	ld	de,4
	add	iy,de
	pop	de
	inc	hl
	ld	a,(ix + _entries)
	sub	l
	jr	nz,rt5
	ld	a,(ix + _entries + 1)
	sub	h
	jr	nz,rt5
	jr	rt6
;
unimplode:
; print method
	call	vprint
	db	'Imploded',0
; print version, date and time
	call	opver
	ld	a,1fh
	ld	(omask),a
	call	ldtrees
ui1:	ld	a,(zipeof)	; test if eof
	and	1
	ret	nz
	inc	a
	call	readbits
	or	a
	jr	z,ui2
	ld	a,(ltp)
	or	a
	jr	z,ui3
	ld	ix,lit_tree
	call	readtree
	jr	ui4
;
ui3:	ld	a,8
	call	rdbybits
ui4:	call	outb
	jr	ui1
;
ui2:	ld	a,(dictb)
	call	readbits
	push	hl
	ld	ix,dist_tre
	call	readtree
	ld	l,a		;;v1.5-1 unimplode fix
	ld	h,0		;;v1.5-1
	ld	bc,(dictb - 1)
ui5:	add	hl,hl
	djnz	ui5
	pop	bc
	add	hl,bc
	push	hl
	ld	ix,len_tree
	call	readtree
	ld	l,a
	ld	h,0
	cp	63
	jr	nz,ui6
	push	hl
	ld	a,8
	call	rdbybits
	pop	de
	add	hl,de
ui6:	ld	de,(mml)
	ld	d,0
	add	hl,de
	ld	b,h
	ld	c,l
	pop	hl
	inc	hl
	call	callback
	jr	ui1
;
nextsymbol:
	ld	(treep),hl
nsloop:	push	hl
	rd1bit
	pop	hl
	or	a
	jr	z,nsleft
	inc	hl
	inc	hl
nsleft:	ld	e,(hl)
	inc	hl
	ld	d,(hl)

	ld	a,d
	cp	10h
	jr	nc,nsleaf
	or	e
	ret	z

	ld	hl,(treep)
	add	hl,de
	add	hl,de
	add	hl,de
	add	hl,de
	jr	nsloop

nsleaf:	and	0fh
	ld	d,a
	ret
;
buildcode:
	ld	(lenp),hl
	ld	(nodes),de
	ld	(nrsym),bc

	ld	hl,blcnt
	ld	de,blcnt + 1
	ld	bc,2 * maxcl + 1
	ld	(hl),b
	ldir

	ld	bc,(nrsym)
	ld	de,(lenp)
bclp1:	ld	a,(de)
	add	a,a
	jr	z,bcnol
	ld	hl,blcnt
	add	a,l
	ld	l,a
	jr	nc,bcnc1
	inc	h
bcnc1:	ld	a,(hl)
	inc	a
	ld	(hl),a
	jr	nz,bcnol
	inc	hl
	inc	(hl)
bcnol:	inc	de
	dec	bc
	ld	a,b
	or	c
	jr	nz,bclp1

	ld	hl,0
	push	hl

	ld	bc,1
bclp2:	ld	a,c
	sub	maxcl + 1
	jr	nc,bccn2

	ld	hl,blcnt
	add	hl,bc
	add	hl,bc
	dec	hl
	ld	d,(hl)
	dec	hl
	ld	e,(hl)

	pop	hl
	add	hl,de
	add	hl,hl
	push	hl

	ex	de,hl
	ld	hl,ncode
	add	hl,bc
	add	hl,bc
	ld	(hl),e
	inc	hl
	ld	(hl),d

	inc	c
	jr	bclp2
bccn2:	pop	hl

	ld	hl,(nrsym)
	add	hl,hl
	add	hl,hl
	ld	b,h
	ld	c,l
	ld	hl,(nodes)
	ld	d,h
	ld	e,l
	inc	de
	dec	bc
	ld	(hl),0
	ldir

	ld	hl,1
	ld	(nnode),hl

	ld	bc,0
bclp3:	ld	hl,(lenp)
	add	hl,bc
	ld	a,(hl)
	or	a
	jr	z,bccn3

	push	bc

	push	af
	ld	hl,ncode
	add	a,a
	add	a,l
	ld	l,a
	jr	nc,bc4
	inc	h
bc4:	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	(bcode),de
	inc	de
	ld	(hl),d
	dec	hl
	ld	(hl),e
	pop	af

	ld	hl,1
bclp4:	dec	a
	or	a
	jr	z,bccn4
	add	hl,hl
	jr	bclp4
bccn4:	ld	(bmask),hl

	ld	hl,(nodes)
bclp5:	ld	de,(bcode)
	ld	bc,(bmask)
	ld	a,d
	and	b
	ld	d,a
	ld	a,e
	and	c
	ld	e,a
	or	d
	jr	z,bcleft
	inc	hl
	inc	hl
bcleft:	srl	b
	rr	c
	ld	(bmask),bc
	ld	a,b
	or	c
	jr	z,bccn5

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	a,d
	or	e
	jr	nz,bc6
	ld	de,(nnode)
	ld	(hl),d
	dec	hl
	ld	(hl),e
	inc	de
	ld	(nnode),de
	dec	de

bc6:	ld	hl,(nodes)
	add	hl,de
	add	hl,de
	add	hl,de
	add	hl,de
	jr	bclp5

bccn5:	pop	bc

	ld	(hl),c
	inc	hl
	ld	a,b
	or	10h
	ld	(hl),a

bccn3:	inc	bc
	ld	hl,(nrsym)
	or	a
	sbc	hl,bc
	jr	nz,bclp3
	ret
;
huffman:
	ld	a,5
	call	rdbybits
	inc	a
	ld	l,a
	ld	h,1
	ld	(hlit),hl

	ld	a,5
	call	rdbybits
	inc	a
	ld	(hdist),a

	ld	a,4
	call	rdbybits
	add	a,4
	ld	c,a

	ld	b,0
	ld	de,clord
hmlp1:	ld	a,b
	cp	c
	jr	nc,hmcn1
	push	bc
	push	de
	ld	a,3
	call	rdbybits
	pop	hl
	ld	c,(hl)
	ld	b,0
	ex	de,hl
	ld	hl,lenld
	add	hl,bc
	ld	(hl),a
	pop	bc
	inc	de
	inc	b
	jr	hmlp1

hmcn1:	xor	a
	ld	c,a
hmlp2:	ld	a,b
	cp	nrcl
	jr	nc,hmcn2
	ld	a,(de)
	ld	hl,lenld
	add	a,l
	ld	l,a
	jr	nc,hmnc2
	inc	h
hmnc2:	ld	(hl),c
	inc	de
	inc	b
	jr	hmlp2

hmcn2:	ld	hl,lenld
	ld	de,cltr
	ld	bc,nrcl
	call	buildcode

	ld	hl,(hlit)
	ld	a,(hdist)
	add	a,l
	ld	c,a
	ld	a,h
	adc	a,0
	ld	b,a
	ld	hl,lenld
hmlp3:	push	bc
	push	hl
	ld	hl,cltr
	call	nextsymbol
	ld	a,e

	cp	010h
	jr	nz,hmn16
	ld	a,2
	call	rdbybits
	pop	hl
	pop	bc
	add	a,3
	ld	d,a
	dec	hl
	ld	e,(hl)
	inc	hl
hmlp4:	ld	(hl),e
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp4
	jr	hmcn3

hmn16:	cp	011h
	jr	nz,hmn17
	ld	a,3
	call	rdbybits
	pop	hl
	pop	bc
	add	a,3
	ld	d,a
	xor	a
hmlp5:	ld	(hl),a
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp5
	jr	hmcn3

hmn17:	cp	012h
	jr	nz,hmn18
	ld	a,7
	call	rdbybits
	pop	hl
	pop	bc
	add	a,11
	ld	d,a
	xor	a
hmlp6:	ld	(hl),a
	inc	hl
	dec	bc
	dec	d
	jr	nz,hmlp6
	jr	hmcn3

hmn18:	pop	hl
	pop	bc
	ld	(hl),a
	inc	hl
	dec	bc

hmcn3:	ld	a,b
	or	c
	jr	nz,hmlp3

	ld	hl,lenld
	ld	de,littr
	ld	bc,(hlit)
	call	buildcode

	ld	hl,(hlit)
	ld	de,lenld
	add	hl,de
	ld	de,disttr
	ld	a,(hdist)
	ld	c,a
	ld	b,0
	call	buildcode

	ld	hl,(inbps)
	ld	a,l
	or	h
	jr	z,hmnext
	ld	(inbufp),hl
	ld	a,(rdpts)
	ld	(readpt),a
	ld	a,(blfts)
	ld	(bleft),a
	ld	a,(bitbs)
	ld	(bitbuf),a
	ld	hl,counting
	inc	(hl)

hmnext:	ld	hl,littr
	call	nextsymbol
	ld	a,d
	dec	a
	or	e
	ret	z
	ld	a,(zipeof)	; test if eof
	and	1
	ret	nz

	ld	a,d
	or	a
	jr	nz,hmsym
	ld	a,e
	call	outb
	jr	hmnext

hmsym:	dec	e
	ld	d,0
	ld	hl,lenex
	add	hl,de
	ld	a,(hl)
	ld	hl,0
	or	a
	jr	z,hmnlen
	push	de
	call	readbits
	pop	de
hmnlen:	push	hl
	ld	hl,lenbas
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	add	hl,de
	push	hl

	ld	hl,disttr
	call	nextsymbol
	ld	hl,dstex
	add	hl,de
	ld	a,(hl)
	ld	hl,0
	or	a
	jr	z,hmndst
	push	de
	call	readbits
	pop	de
hmndst:	push	hl
	ld	hl,dstbas
	add	hl,de
	add	hl,de
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	pop	de
	add	hl,de

	pop	bc
	call	callback
	jr	hmnext
;
undeflate:
; print method
	call	vprint
	db	'Deflated',0
; print version, date and time
	call	opver
	ld	a,7fh
	ld	(omask),a

udloop:	ld	a,(zipeof)	; test if eof
	and	1
	ret	nz

	rd1bit
	push	af

	ld	a,2
	call	rdbybits
	or	a
	jr	nz,udnt0

	xor	a
	ld	(bleft),a
	ld	a,16
	call	readbits
	push	hl
	ld	a,16
	call	readbits
	pop	bc
	scf
	adc	hl,bc
	jr	nz,udblm

udt0lp:	ld	a,b
	or	c
	jr	z,udnext
	ld	a,(zipeof)	; test if eof
	and	1
	jr	nz,udpret
	push	bc
	call	getbyte
	call	outb
	pop	bc
	dec	bc
	jr	udt0lp

udnt0:	dec	a
	jr	nz,udnt1
	ld	hl,(inbufp)
	ld	(inbps),hl
	ld	a,(readpt)
	ld	(rdpts),a
	ld	a,(bleft)
	ld	(blfts),a
	ld	a,(bitbuf)
	ld	(bitbs),a
	ld	hl,counting
	dec	(hl)
	ld	hl,static_pre
	ld	(inbufp),hl
	xor	a
	ld	(readpt),a
	ld	(bleft),a
	call	huffman
	jr	udnext

udnt1:	dec	a
	jr	nz,udubt
	ld	hl,0
	ld	(inbps),hl
	call	huffman

udnext:	pop	af
	or	a
	jp	z,udloop
	ret

udpret:	pop	af
	ret
udbskp:	ld	a,(zipeof)	; test if eof
	and	1
	jr	nz,udpret
	call	getbyte
	jr	udbskp
udblm:	call	vprint
	db	'Block length mismatch',CR,LF,0
	jr	udbskp
udubt:	call	vprint
	db	'Unknown block type',CR,LF,0
	jr	udbskp
; Print drive and user # - H has drive and L has user #
printDU:	
	ld	a,h		;drive 0 => default drive
	dec	a
	jp	p,notDEF	
; default drive
	ld	c,25		;get default drive
	push	hl		;just to be safe
	call	bdos
	pop	hl		
notDEF:
	add	a,'A'		;convert to ASCII
	call	cout		;perserves registers
	ld	a,(zflag)
	or	a
	ld	a,l		;get user code
	jr	nz,notDFU
	bit	7,a		;default user?
	jr	nz,notDFU
	ld	e,0ffh
	ld	c,32
	call	bdos		;retuens default user # in A	
notDFU:	and	1fh
	call	PAFDC		;output A as decimal digits 	
	ld	a,':'
	jp	cout
;
; opsiz - output uncompressed and compressed file size as 7 
;		blank filled digits
opsiz:
; First print uncompressed size
	call	vprint
	db	' ',0
	ld	hl,ucs
	ld	a,7
	call	plwdc
	call	vprint
	db	' ',0
;
; now output compressed file size as 7 blank filled digits
	ld	hl,cs
	ld	a,7
	call	plwdc
	call	vprint
	db	' ',0
	ret
;
; opver - output zip version
;
opver:
	call	vprint
	db	'  ',0
	ld	hl,(lfh)
	call	phl2dc
	call	vprint
	db	'  ',0
;	ret
;
; opdat - output date and time
;
opdat:
; First convert date from MSDOS to universal format
	ld	hl,(lmfd)	; HL<-modify date
	ld	de,dsbuf	; put date stamp here
	call	dcvt		; date now in create buffer
; Then convert time from MSDOS to universal format
	ld	hl,(lmft)	; get modify time
	call	tcvt		; time now in create stamp
; print date as day then month 
	ld	a,0ffh		; choose day then month
	ld	hl,dsbuf
	call	pdats2		; print date
	call	vprint
	db	'  ',0
; print time in military format
	ld	a,0ffh		; choose military format
	ld	hl,dsbuf	; point to BCD date sting
	call	ptims1		; print time
	call	vprint
	db	' ',0
; print 32 bit CRC as 8 hex digits (assume CRC stored little endian)
	ld	hl,(crc+2)	; most significant 16 bits
	call	PHL4HC		; print as 4 hex digits
	ld	hl,(crc)	; least significant 16 bits
	call	PHL4HC
	call	vprint
	db	'  ',0
	ret
;
; dcvt - convert MS-DOS date to DateStamper format
;   Enter:  	HL = MS-DOS formatted date word
;		DE = Pointer to storage buffer in DE. 
;
; MS-DOS 16-bit date format:
; Bits [15:9] = year - 1980
; Bits	[8:5] = month of year
; Bits	[4:0] = day of month
;
dcvt:
; shift HL right one bit so HL has year and month in high order
; bits of L
	ld	c,l		; save L
	srl	h		; Shift H right, LSB to carry
	rr	l		; Shift L right, carry to MSB
	ld	a,h
	sub	20		; try 2000 and greater
	jr	nc,y2k
	add	a,80+20		; 80 to 99
y2k:	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
; shift month to bits [3:0] of L
	SRL	L		; Shift L right, carry ignored
	SRL	L		; Shift L right, carry ignored
	SRL	L		; Shift L right, carry ignored
	SRL	L		; month now in L 
	ld	a,l
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ld	a,c		; get day
	and	1Fh
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ret
;
; tcvt - Convert time from MS-DOS to DateStamper format and save in 
; storage buffer.  Seconds not converted.
;   Enter:  	HL = MS-DOS formatted time word
;		DE = Pointer to storage buffer in DE. 
;
; MS-DOS 16-bit packed binary time format
;    Bits	[15:11] = hours
;    Bits	[10:5]  = minutes
;    Bits	[4:0]   = seconds/2
;
tcvt:	ld	b,3		; Loop counter for shifting
tcvtlp:	srl	h		; Shift H right, LSB to carry
	rr	l		; Shift L right, carry to MSB
	djnz	tcvtlp		; Repeat 3 times. when done, hours in H
	SRL	L		; Shift L right, carry ignored
	srl	l		; Now have minutes in L
	ld	A,H		; Get hours in A
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
	inc	de		; Advance pointer
	ld	a,l		; Now do minutes
	call	binbcd		; Convert to BCD
	ld	(de),a		; Store in buffer
;	inc	de		; Advance pointer
	ret
;
; Convert BIN to BCD
; Enter: A = Binary number to be converted
; Exit : A = Two BCD digits
;		 All registers preserved
;
BINBCD: OR	A
	RET	Z		; Zero is same
	PUSH	BC		; Save register
	LD	B,A		; Set counter
	XOR	A
BCDLP:	INC	A		; Count up BCD..
	DAA
	DJNZ	BCDLP		; ..til all gone
	POP	BC
	RET
;
; data storage . . .
;
zipeof:	db	2
counting:
	db	0
init:
	db	0	; for bleft
	db	0	; for wrtpt
	dw	0,0	; for outpos
	dw	-1,-1	; for crc32
endinit:
dsbuf:	db	0,0,0,0,0
inbufp:	dw	0080h
readpt:	db	80h		;was 0
omask:	db	1fh
_L_table:
	db	7fh, 3fh, 1fh, 0fh
_D_shift:
	db	07h, 06h, 05h, 04h
clord:	db	16, 17, 18
	db	0, 8
	db	7, 9
	db	6, 10
	db	5, 11
	db	4, 12
	db	3, 13
	db	2, 14
	db	1, 15
lenbas:	dw	3, 4
	dw	5, 6
	dw	7, 8
	dw	9, 10
	dw	11, 13
	dw	15, 17
	dw	19, 23
	dw	27, 31
	dw	35, 43
	dw	51, 59
	dw	67, 83
	dw	99, 115
	dw	131, 163
	dw	195, 227
	dw	258
lenex:	db	0, 0
	db	0, 0
	db	0, 0
	db	0, 0
	db	1, 1
	db	1, 1
	db	2, 2
	db	2, 2
	db	3, 3
	db	3, 3
	db	4, 4
	db	4, 4
	db	5, 5
	db	5, 5
	db	0
dstbas:	dw	1, 2
	dw	3, 4
	dw	5, 7
	dw	9, 13
	dw	17, 25
	dw	33, 49
	dw	65, 97
	dw	129, 193
	dw	257, 385
	dw	513, 769
	dw	1025, 1537
	dw	2049, 3073
	dw	4097, 6145
	dw	8193, 12289
	dw	16385, 24577
dstex:	db	0, 0
	db	0, 0
	db	1, 1
	db	2, 2
	db	3, 3
	db	4, 4
	db	5, 5
	db	6, 6
	db	7, 7
	db	8, 8
	db	9, 9
	db	10, 10
	db	11, 11
	db	12, 12
	db	13, 13
static_pre:
	db	0ffh, 05bh, 000h, 06ch, 003h, 036h, 0dbh, 0b6h
	db	06dh, 0dbh, 0b6h, 06dh, 0dbh, 0b6h, 0cdh, 0dbh
	db	0b6h, 06dh, 0dbh, 0b6h, 06dh, 0dbh, 0a8h, 06dh
	db	0ceh, 08bh, 06dh, 03bh
;
crc32tab:	; crc32_tab[] from degzip_portable.c, takes 1k
	db	000h,000h,000h,000h,096h,030h,007h,077h
	db	02Ch,061h,00Eh,0EEh,0BAh,051h,009h,099h
	db	019h,0C4h,06Dh,007h,08Fh,0F4h,06Ah,070h
	db	035h,0A5h,063h,0E9h,0A3h,095h,064h,09Eh
	db	032h,088h,0DBh,00Eh,0A4h,0B8h,0DCh,079h
	db	01Eh,0E9h,0D5h,0E0h,088h,0D9h,0D2h,097h
	db	02Bh,04Ch,0B6h,009h,0BDh,07Ch,0B1h,07Eh
	db	007h,02Dh,0B8h,0E7h,091h,01Dh,0BFh,090h
	db	064h,010h,0B7h,01Dh,0F2h,020h,0B0h,06Ah
	db	048h,071h,0B9h,0F3h,0DEh,041h,0BEh,084h
	db	07Dh,0D4h,0DAh,01Ah,0EBh,0E4h,0DDh,06Dh
	db	051h,0B5h,0D4h,0F4h,0C7h,085h,0D3h,083h
	db	056h,098h,06Ch,013h,0C0h,0A8h,06Bh,064h
	db	07Ah,0F9h,062h,0FDh,0ECh,0C9h,065h,08Ah
	db	04Fh,05Ch,001h,014h,0D9h,06Ch,006h,063h
	db	063h,03Dh,00Fh,0FAh,0F5h,00Dh,008h,08Dh
	db	0C8h,020h,06Eh,03Bh,05Eh,010h,069h,04Ch
	db	0E4h,041h,060h,0D5h,072h,071h,067h,0A2h
	db	0D1h,0E4h,003h,03Ch,047h,0D4h,004h,04Bh
	db	0FDh,085h,00Dh,0D2h,06Bh,0B5h,00Ah,0A5h
	db	0FAh,0A8h,0B5h,035h,06Ch,098h,0B2h,042h
	db	0D6h,0C9h,0BBh,0DBh,040h,0F9h,0BCh,0ACh
	db	0E3h,06Ch,0D8h,032h,075h,05Ch,0DFh,045h
	db	0CFh,00Dh,0D6h,0DCh,059h,03Dh,0D1h,0ABh
	db	0ACh,030h,0D9h,026h,03Ah,000h,0DEh,051h
	db	080h,051h,0D7h,0C8h,016h,061h,0D0h,0BFh
	db	0B5h,0F4h,0B4h,021h,023h,0C4h,0B3h,056h
	db	099h,095h,0BAh,0CFh,00Fh,0A5h,0BDh,0B8h
	db	09Eh,0B8h,002h,028h,008h,088h,005h,05Fh
	db	0B2h,0D9h,00Ch,0C6h,024h,0E9h,00Bh,0B1h
	db	087h,07Ch,06Fh,02Fh,011h,04Ch,068h,058h
	db	0ABh,01Dh,061h,0C1h,03Dh,02Dh,066h,0B6h
	db	090h,041h,0DCh,076h,006h,071h,0DBh,001h
	db	0BCh,020h,0D2h,098h,02Ah,010h,0D5h,0EFh
	db	089h,085h,0B1h,071h,01Fh,0B5h,0B6h,006h
	db	0A5h,0E4h,0BFh,09Fh,033h,0D4h,0B8h,0E8h
	db	0A2h,0C9h,007h,078h,034h,0F9h,000h,00Fh
	db	08Eh,0A8h,009h,096h,018h,098h,00Eh,0E1h
	db	0BBh,00Dh,06Ah,07Fh,02Dh,03Dh,06Dh,008h
	db	097h,06Ch,064h,091h,001h,05Ch,063h,0E6h
	db	0F4h,051h,06Bh,06Bh,062h,061h,06Ch,01Ch
	db	0D8h,030h,065h,085h,04Eh,000h,062h,0F2h
	db	0EDh,095h,006h,06Ch,07Bh,0A5h,001h,01Bh
	db	0C1h,0F4h,008h,082h,057h,0C4h,00Fh,0F5h
	db	0C6h,0D9h,0B0h,065h,050h,0E9h,0B7h,012h
	db	0EAh,0B8h,0BEh,08Bh,07Ch,088h,0B9h,0FCh
	db	0DFh,01Dh,0DDh,062h,049h,02Dh,0DAh,015h
	db	0F3h,07Ch,0D3h,08Ch,065h,04Ch,0D4h,0FBh
	db	058h,061h,0B2h,04Dh,0CEh,051h,0B5h,03Ah
	db	074h,000h,0BCh,0A3h,0E2h,030h,0BBh,0D4h
	db	041h,0A5h,0DFh,04Ah,0D7h,095h,0D8h,03Dh
	db	06Dh,0C4h,0D1h,0A4h,0FBh,0F4h,0D6h,0D3h
	db	06Ah,0E9h,069h,043h,0FCh,0D9h,06Eh,034h
	db	046h,088h,067h,0ADh,0D0h,0B8h,060h,0DAh
	db	073h,02Dh,004h,044h,0E5h,01Dh,003h,033h
	db	05Fh,04Ch,00Ah,0AAh,0C9h,07Ch,00Dh,0DDh
	db	03Ch,071h,005h,050h,0AAh,041h,002h,027h
	db	010h,010h,00Bh,0BEh,086h,020h,00Ch,0C9h
	db	025h,0B5h,068h,057h,0B3h,085h,06Fh,020h
	db	009h,0D4h,066h,0B9h,09Fh,0E4h,061h,0CEh
	db	00Eh,0F9h,0DEh,05Eh,098h,0C9h,0D9h,029h
	db	022h,098h,0D0h,0B0h,0B4h,0A8h,0D7h,0C7h
	db	017h,03Dh,0B3h,059h,081h,00Dh,0B4h,02Eh
	db	03Bh,05Ch,0BDh,0B7h,0ADh,06Ch,0BAh,0C0h
	db	020h,083h,0B8h,0EDh,0B6h,0B3h,0BFh,09Ah
	db	00Ch,0E2h,0B6h,003h,09Ah,0D2h,0B1h,074h
	db	039h,047h,0D5h,0EAh,0AFh,077h,0D2h,09Dh
	db	015h,026h,0DBh,004h,083h,016h,0DCh,073h
	db	012h,00Bh,063h,0E3h,084h,03Bh,064h,094h
	db	03Eh,06Ah,06Dh,00Dh,0A8h,05Ah,06Ah,07Ah
	db	00Bh,0CFh,00Eh,0E4h,09Dh,0FFh,009h,093h
	db	027h,0AEh,000h,00Ah,0B1h,09Eh,007h,07Dh
	db	044h,093h,00Fh,0F0h,0D2h,0A3h,008h,087h
	db	068h,0F2h,001h,01Eh,0FEh,0C2h,006h,069h
	db	05Dh,057h,062h,0F7h,0CBh,067h,065h,080h
	db	071h,036h,06Ch,019h,0E7h,006h,06Bh,06Eh
	db	076h,01Bh,0D4h,0FEh,0E0h,02Bh,0D3h,089h
	db	05Ah,07Ah,0DAh,010h,0CCh,04Ah,0DDh,067h
	db	06Fh,0DFh,0B9h,0F9h,0F9h,0EFh,0BEh,08Eh
	db	043h,0BEh,0B7h,017h,0D5h,08Eh,0B0h,060h
	db	0E8h,0A3h,0D6h,0D6h,07Eh,093h,0D1h,0A1h
	db	0C4h,0C2h,0D8h,038h,052h,0F2h,0DFh,04Fh
	db	0F1h,067h,0BBh,0D1h,067h,057h,0BCh,0A6h
	db	0DDh,006h,0B5h,03Fh,04Bh,036h,0B2h,048h
	db	0DAh,02Bh,00Dh,0D8h,04Ch,01Bh,00Ah,0AFh
	db	0F6h,04Ah,003h,036h,060h,07Ah,004h,041h
	db	0C3h,0EFh,060h,0DFh,055h,0DFh,067h,0A8h
	db	0EFh,08Eh,06Eh,031h,079h,0BEh,069h,046h
	db	08Ch,0B3h,061h,0CBh,01Ah,083h,066h,0BCh
	db	0A0h,0D2h,06Fh,025h,036h,0E2h,068h,052h
	db	095h,077h,00Ch,0CCh,003h,047h,00Bh,0BBh
	db	0B9h,016h,002h,022h,02Fh,026h,005h,055h
	db	0BEh,03Bh,0BAh,0C5h,028h,00Bh,0BDh,0B2h
	db	092h,05Ah,0B4h,02Bh,004h,06Ah,0B3h,05Ch
	db	0A7h,0FFh,0D7h,0C2h,031h,0CFh,0D0h,0B5h
	db	08Bh,09Eh,0D9h,02Ch,01Dh,0AEh,0DEh,05Bh
	db	0B0h,0C2h,064h,09Bh,026h,0F2h,063h,0ECh
	db	09Ch,0A3h,06Ah,075h,00Ah,093h,06Dh,002h
	db	0A9h,006h,009h,09Ch,03Fh,036h,00Eh,0EBh
	db	085h,067h,007h,072h,013h,057h,000h,005h
	db	082h,04Ah,0BFh,095h,014h,07Ah,0B8h,0E2h
	db	0AEh,02Bh,0B1h,07Bh,038h,01Bh,0B6h,00Ch
	db	09Bh,08Eh,0D2h,092h,00Dh,0BEh,0D5h,0E5h
	db	0B7h,0EFh,0DCh,07Ch,021h,0DFh,0DBh,00Bh
	db	0D4h,0D2h,0D3h,086h,042h,0E2h,0D4h,0F1h
	db	0F8h,0B3h,0DDh,068h,06Eh,083h,0DAh,01Fh
	db	0CDh,016h,0BEh,081h,05Bh,026h,0B9h,0F6h
	db	0E1h,077h,0B0h,06Fh,077h,047h,0B7h,018h
	db	0E6h,05Ah,008h,088h,070h,06Ah,00Fh,0FFh
	db	0CAh,03Bh,006h,066h,05Ch,00Bh,001h,011h
	db	0FFh,09Eh,065h,08Fh,069h,0AEh,062h,0F8h
	db	0D3h,0FFh,06Bh,061h,045h,0CFh,06Ch,016h
	db	078h,0E2h,00Ah,0A0h,0EEh,0D2h,00Dh,0D7h
	db	054h,083h,004h,04Eh,0C2h,0B3h,003h,039h
	db	061h,026h,067h,0A7h,0F7h,016h,060h,0D0h
	db	04Dh,047h,069h,049h,0DBh,077h,06Eh,03Eh
	db	04Ah,06Ah,0D1h,0AEh,0DCh,05Ah,0D6h,0D9h
	db	066h,00Bh,0DFh,040h,0F0h,03Bh,0D8h,037h
	db	053h,0AEh,0BCh,0A9h,0C5h,09Eh,0BBh,0DEh
	db	07Fh,0CFh,0B2h,047h,0E9h,0FFh,0B5h,030h
	db	01Ch,0F2h,0BDh,0BDh,08Ah,0C2h,0BAh,0CAh
	db	030h,093h,0B3h,053h,0A6h,0A3h,0B4h,024h
	db	005h,036h,0D0h,0BAh,093h,006h,0D7h,0CDh
	db	029h,057h,0DEh,054h,0BFh,067h,0D9h,023h
	db	02Eh,07Ah,066h,0B3h,0B8h,04Ah,061h,0C4h
	db	002h,01Bh,068h,05Dh,094h,02Bh,06Fh,02Ah
	db	037h,0BEh,00Bh,0B4h,0A1h,08Eh,00Ch,0C3h
	db	01Bh,0DFh,005h,05Ah,08Dh,0EFh,002h,02Dh


	end	;start
